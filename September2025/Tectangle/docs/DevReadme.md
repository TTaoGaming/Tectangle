# DEV_README — September Tectangle (canonical)

Generated by consolidation on 2025-09-01T19:25:01Z — human-verified: false

Update: 2025-09-01T17:42:26Z — Meta-generation push & next actions

- Branch pushed: `chore/meta-gen` (generated manager meta files + meta-check scripts) to https://github.com/TTaoGaming/Tectangle on 2025-09-01T17:38:29Z. PR creation URL: https://github.com/TTaoGaming/Tectangle/pull/new/chore-meta-gen
- CI: The meta-check job defined in [`.github/workflows/meta-check.yml`](.github/workflows/meta-check.yml:1) runs `npm run check:meta` inside the package. The check may report MISSING or PRESENT‑DRIFT until [`docs/header-schema.json`](docs/header-schema.json:1) is restored and any generated `src/*.meta.json` are accepted.
- Local troubleshooting: generated meta lives in [`August Tectangle Sprint/tectangle-gesture-keyboard-mobile/tmp/generated-meta/`](August Tectangle Sprint/tectangle-gesture-keyboard-mobile/tmp/generated-meta/:1). To iterate locally:
  - cd "August Tectangle Sprint/tectangle-gesture-keyboard-mobile" && npm run generate:meta
  - Inspect: type tmp\generated-meta\<Name>.meta.json
  - Accept changes: copy tmp/generated-meta/<Name>.meta.json → src/<Name>.meta.json ; then npm run check:meta
- Note: I did not create the PR on your behalf (no tokens). Create the PR using the URL above or via GitHub UI.

---

## Workflow

// Updated: 2025-08-31T21:53:50Z

TLDR: Clear 5-step non-coder workflow, an AI playbook, and three standardization options.

Purpose and quick links

This document explains a non-coder-friendly day-to-day workflow and provides an AI playbook so humans and agents follow the same, safe rules. See the repo overview in [`DEV_README.md`](DEV_README.md:1) and the testing conventions in [`teststrategyREADME.md`](teststrategyREADME.md:1).

Quick links

- Workflow and AI playbook: [`workflowREADME.md`](workflowREADME.md:1)
- Test strategy and templates: [`teststrategyREADME.md`](teststrategyREADME.md:1)
- Main dev README: [`DEV_README.md`](DEV_README.md:1)

5-step workflow (non-coder friendly)

1. Setup (one-time)

- Open a terminal at the repository root and run:

  npm install

- Explanation: installs dev dependencies used by tests and scripts.

2. Run tests

- Run the full test suite:

  npm test

- Or run a single test with Node built-in:

  node --test "August Tectangle Sprint/tectangle-gesture-keyboard-mobile/tests/unit/landmarkSmooth.oneEuro.test.mjs"

3. Find the top failing red test

- Open the failing test file (example):

  [`August Tectangle Sprint/tectangle-gesture-keyboard-mobile/tests/unit/landmarkSmooth.oneEuro.test.mjs`](August Tectangle Sprint/tectangle-gesture-keyboard-mobile/tests/unit/landmarkSmooth.oneEuro.test.mjs:1)

- Explanation: the red test defines the behavior you want; keep it small and focused.

4. Implement minimal green

- Make the smallest, surgical change that makes the test pass. Prefer edit-in-place (apply small diffs).

- Run the single test until it passes:

  node --test "<file>"

5. PR & validation

- Run header checks and full tests:

  npm run check-headers
  npm test

- In the PR description list tests run and attach golden traces if used.

AI Agent Playbook (copy-paste safe commands and constraints)

## Anti-regression checklist

Include these items in any PR touching core managers (EventBus, CameraManager, LandmarkSmoothManager):

- Telemetry counters — instrument and snapshot counters in [`August Tectangle Sprint/tectangle-gesture-keyboard-mobile/src/TelemetryManager.js`](August Tectangle Sprint/tectangle-gesture-keyboard-mobile/src/TelemetryManager.js:1). Record a baseline before the change and report counter deltas in the PR.

- Golden traces — add 1–3s golden traces under [`prototype/landmark-smooth/golden/`](prototype/landmark-smooth/golden/:1). Attach traces to the PR and require CI smoke replay for modified managers.

- CI gating — require header checks (`npm run check-headers`), unit tests for changed files, and smoke replay for affected manager paths.

- Quarantine flaky tests — mark flaky tests as skipped, file an issue labeled `flaky-test` with stderr + golden trace, and list quarantined tests in docs.

- Nightly smoke job — run nightly replay of all golden traces and publish telemetry snapshots to aid triage.

- Runbook — follow [`August Tectangle Sprint/tectangle-gesture-keyboard-mobile/docs/regression_runbook.md`](August Tectangle Sprint/tectangle-gesture-keyboard-mobile/docs/regression_runbook.md:1) for step-by-step triage.

Allowed read/run commands (copy/paste)

- npm install
- npm test
- node --test "<file>"
- npx mocha "<pattern>"
- npm run check-headers
- rg "<pattern>" (ripgrep) to find code/tests

Safe-edit ruleset (must follow)

- Add tests first: always create a failing red test under [`tests/`](tests/:1) before making code edits.
- Edit only these paths unless explicitly instructed: [`src/`](src/:1), [`tests/`](tests/:1), [`docs/`](docs/:1), [`package.json`](package.json:1).
- Prefer surgical patches: keep diffs < 300 LOC; prefer apply_diff / patch-style edits and small, focused commits.
- Preserve header/meta blocks; run header checks with:

  node "August Tectangle Sprint/tectangle-gesture-keyboard-mobile/scripts/check_headers.js"

- Do not change binary files, large archive folders, or anything under `archive-stale/` without human approval.
- When in doubt, open an issue and include the failing test and environment (OS, Node version).

How to produce a minimal diff (example)

- Create a red test in [`tests/unit/`](tests/unit/:1), run it, then apply a single small patch that changes one function. Include the test and a short PR summary referencing the test file and commands run.

Three viable approaches to standardization

1. Minimal policy (Quick wins) — Recommended? No

Summary: Establish a small set of rules (test-first, header checks, allowed edit paths) and enforce them with lightweight scripts and PR templates.

Rationale: Low friction and fast to adopt.

Confidence: 80%

Estimated_cost_time: Quick / ~4–12 hours

Next steps:

- Add PR template and small scripts to run header checks and tests.

Files affected:

- [`package.json`](package.json:1)

Risk: Low — limited scope and incremental.

2. Telemetry + TDD (Recommended)

Summary: Instrument core managers, require TDD-first for changes, and add golden traces to ensure deterministic behavior for smoke tests.

Rationale: Stabilizes behavior where it matters and supports reliable AI edits and CI.

Confidence: 75%

Estimated_cost_time: Small / ~2–5 days

Next steps:

- Add telemetry hooks to `src/` managers and store golden traces in [`prototype/landmark-smooth/golden/`](prototype/landmark-smooth/golden/:1).
- Write TDD-first tests for 3 critical managers (EventBus, Camera, LandmarkSmooth).

Files affected:

- [`August Tectangle Sprint/tectangle-gesture-keyboard-mobile/src/EventBusManager.js`](August Tectangle Sprint/tectangle-gesture-keyboard-mobile/src/EventBusManager.js:1)
- [`August Tectangle Sprint/tectangle-gesture-keyboard-mobile/src/CameraManager.js`](August Tectangle Sprint/tectangle-gesture-keyboard-mobile/src/CameraManager.js:1)
- [`prototype/landmark-smooth/golden/`](prototype/landmark-smooth/golden/:1)

Risk: Medium — requires small instrumentation and CI changes.

3. Repo reorg / strict monorepo (Large)

Summary: Restructure packages into a strict monorepo layout with enforced boundaries and CI gates.

Rationale: Long-term scalability and clearer package boundaries.

Confidence: 60%

Estimated_cost_time: Large / ~2–4 weeks

Next steps:

- Prototype package boundaries and CI gating on a small subset of packages.

Files affected:

- repo-level manifest files (e.g., [`package.json`](package.json:1)) and many folders under the repo root (high-level change).

Risk: High — large refactor, higher chance of breaking CI.

Recommended option and why

- Recommended: Telemetry + TDD (Approach 2). It balances safety and long-term payoff: small, testable changes that make CI and AI edits reliable.

Non-coder learning path (guided)

0–4 hours (primer)

- Learn how to open a terminal, run `npm install`, and `npm test`. Resources: GitHub Learning Lab, Node.js docs (free).

1–2 days (short course)

- Intro to Git and PRs (GitHub flow), a short Mocha/Node tutorial (freeCodeCamp/Udemy).

2–4 weeks (practical labs)

- Follow a guided lab: write 3 red->green->refactor cycles for small managers (EventBus, LandmarkSmooth, Camera) and practice opening PRs.

One-line recommended immediate next step

Run `npm install` then `npm test` and open the top failing red test file listed by the runner.

---

## Snapshot & Safe AI Edits Policy

To make AI-assisted edits and other nontrivial changes safe and auditable, follow this lightweight policy:

1. Create a workspace snapshot (one-time per PR):

   - Windows (PowerShell): `powershell -ExecutionPolicy Bypass -File .\scripts\snapshot-workspace.ps1`
   - Unix/macOS: `sh scripts/snapshot-workspace.sh`
   - Snapshot will be stored under `archive-stale/archive-<timestamp>/`.
   - When opening a PR, include a line in the PR description:
     `BACKUP-CREATED: archive-stale/archive-YYYY-MM-DDTHH-MM-SSZ`

2. Use the PR template:

   - The repository includes a PR template: [`.github/PULL_REQUEST_TEMPLATE.md`](.github/PULL_REQUEST_TEMPLATE.md:1). Use its checklist.

3. CI enforcement:

   - A GitHub Actions workflow (`.github/workflows/safe-edit.yml`) runs header checks (if available) and requires the `BACKUP-CREATED:` line in the PR body.

4. Header metadata for AI-generated docs:

   - If a doc is AI-generated, add a short YAML header at the top:
     ```
     ---
     generated_by: ai
     generated_at: 2025-08-18T03:18:28Z
     human_verified: false
     ---
     ```
   - After a human verifies the doc, set `human_verified: true`.

5. Why this exists:
   - Keeps an immutable snapshot for recovery and human review, reduces accidental loss from automated edits, and provides a minimal audit trail for automated changes.
