<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Tectangle — Pinch Piano (Two‑Hand, Palm‑Gated)</title>
  <style>
    :root {
      --bg: #0b0d10; --fg: #e7edf3; --muted: #9fb3c8; --accent: #82d4ff; --ok:#20c997; --warn:#ffb020; --bad:#ff6b6b;
      --key-bg:#0e1420; --key-on:#2a87ff; --key-left:#93d977; --key-right:#82d4ff;
    }
    * { box-sizing: border-box; }
    body { margin:0; font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, sans-serif; background: var(--bg); color: var(--fg); }
    header { padding: 16px 20px; border-bottom: 1px solid #1a222c; background: #0f141a; position: sticky; top: 0; z-index: 5; }
    header h1 { margin:0; font-size: 18px; letter-spacing: .3px; }
    .row { display:flex; gap:16px; padding: 16px 20px; flex-wrap: wrap; }
    .col { flex: 1 1 460px; min-width: 320px; }
    video, canvas { width: 100%; max-width: 100%; border: 1px solid #1a222c; border-radius: 12px; background: #0c1117; display:block; }
    .panel { border: 1px solid #1a222c; border-radius: 12px; padding: 12px; background: #0c1117; }
    .panel h3 { margin: 0 0 8px; font-size: 14px; color: var(--muted); }
    .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px,1fr)); gap: 8px; }
    .control { display:flex; align-items:center; gap: 10px; background:#0f141a; border:1px solid #1a222c; padding:8px 10px; border-radius: 10px; }
    .control .lbl { width: 130px; color: var(--muted); font-size: 12px; }
    .control input[type="range"] { width: 100%; }
    .control .val { min-width: 42px; text-align: right; font-variant-numeric: tabular-nums; color: var(--fg); font-size: 12px; }
    .btn { cursor:pointer; background:#11202b; color: var(--fg); border:1px solid #1a222c; padding:8px 12px; border-radius:10px; display:inline-flex; align-items:center; gap:8px; }
    .btn:hover { background:#122636; }
    .badge { padding: 2px 8px; border-radius: 999px; font-size: 12px; border: 1px solid #1a222c; background:#0f141a; color: var(--muted); }
    .kv { display:grid; grid-template-columns: 1fr auto; gap: 6px 10px; align-items: center; }
    .kv div:nth-child(2n) { color: var(--muted); text-align:right; }
    footer { padding: 16px 20px; border-top:1px solid #1a222c; color: var(--muted); }
    .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; margin-right: 4px; }
    .ok{ background:#0d1e17; color:#7be1bf; }
    .warn{ background:#1d1a0c; color:#ffd47a; }
    .bad{ background:#2a1414; color:#ff9a9a; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    .mini { font-size: 12px; color: var(--muted); }

    /* Virtual keyboard */
    .kbd { display:flex; gap: 10px; }
    .key { position: relative; width: 80px; height: 100px; background: var(--key-bg); border:1px solid #1a222c; border-radius: 12px; display:flex; align-items:center; justify-content:center; font-size: 28px; color: var(--muted); transition: transform .05s ease, box-shadow .05s ease; }
    .key .note { position:absolute; bottom:6px; font-size: 12px; color: var(--muted); }
    .key.right { outline: 2px solid var(--key-right); }
    .key.left  { outline: 2px solid var(--key-left); }
    .key.down  { background: #071325; color: #d9eeff; transform: translateY(2px); box-shadow: inset 0 0 0 2px var(--key-on); }
    .key.hold  { box-shadow: inset 0 0 0 2px var(--ok); }

    /* Tooltip helper */
    .hint { border-bottom: 1px dotted #5a7086; cursor: help; }
  </style>
</head>
<body>
<header>
  <h1>Tectangle — Pinch Piano (Palm‑Gated Index↔Thumb, Two‑Hand) <span class="badge" id="status">ready</span></h1>
</header>

<div class="row">
  <div class="col">
    <video id="cam" playsinline muted autoplay></video>
  </div>
  <div class="col">
    <canvas id="overlay" width="960" height="540"></canvas>
  </div>
</div>

<div class="row">
  <div class="col panel">
    <h3>Controls</h3>
    <div class="controls">
      <div class="control" title="Start/stop camera and landmark pipeline">
        <label class="lbl"><input type="checkbox" id="startStop"> Start camera</label>
        <span class="val"> </span>
      </div>
      <div class="control" title="Require palm normal to face camera within this cone">
        <label class="lbl"><input type="checkbox" id="palmGate" checked> Palm gate</label>
        <input type="range" id="cone" min="10" max="60" step="1" value="30">
        <output class="val" id="coneOut">30°</output>
      </div>
      <div class="control" title="Emit early speculative pinch:down based on time‑to‑impact estimate; cancelled if not confirmed soon">
        <label class="lbl"><input type="checkbox" id="speculative" checked> Speculative down</label>
        <span class="val"> </span>
      </div>
      <div class="control" title="Threshold to ENTER pinch (normalized distance). Lower = more sensitive">
        <span class="lbl">Enter threshold</span>
        <input type="range" id="enter" min="0.05" max="0.90" step="0.01" value="0.40">
        <output class="val" id="enterOut">0.40</output>
      </div>
      <div class="control" title="Threshold to EXIT pinch (normalized distance). Higher = stickier holds">
        <span class="lbl">Exit threshold</span>
        <input type="range" id="exit"  min="0.10" max="0.95" step="0.01" value="0.60">
        <output class="val" id="exitOut">0.60</output>
      </div>
      <div class="control" title="OneEuro filter: lowers jitter while adapting cutoff by motion speed">
        <span class="lbl">MinCutoff</span>
        <input type="range" id="minCutoff" min="0.1" max="3.0" step="0.1" value="1.0">
        <output class="val" id="minCutoffOut">1.0</output>
      </div>
      <div class="control" title="OneEuro beta: responsiveness to speed (higher = snappier but noisier)">
        <span class="lbl">Beta</span>
        <input type="range" id="beta" min="0.00" max="0.10" step="0.005" value="0.01">
        <output class="val" id="betaOut">0.01</output>
      </div>
      <div class="control" title="OneEuro derivative cutoff">
        <span class="lbl">dCutoff</span>
        <input type="range" id="dCutoff" min="0.1" max="3.0" step="0.1" value="1.0">
        <output class="val" id="dCutoffOut">1.0</output>
      </div>
      <div class="control" title="Play a short sine tone on pinch for instant feedback">
        <label class="lbl"><input type="checkbox" id="beep" checked> Audio beep</label>
        <span class="val"> </span>
      </div>
      <div class="control" title="Send MIDI NoteOn/Off to the first output device (Chrome)">
        <label class="lbl"><input type="checkbox" id="midi"> WebMIDI</label>
        <span class="val"> </span>
      </div>
      <div class="control" title="Run a quick open/close to estimate knuckle span (per hand)">
        <button class="btn" id="calibrate">Calibration wizard</button>
        <span class="mini">Saves span per hand</span>
      </div>
      <div class="control" title="Record telemetry/goldens and download as JSONL for CI replay">
        <button class="btn" id="download">Download golden JSONL</button>
        <span class="mini">First line has meta</span>
      </div>
      <div class="control" title="Load a local MP4 for offline processing (no camera)">
        <button class="btn" id="loadVideo">Load video file</button>
        <input type="file" id="videoFile" accept="video/*" style="display:none" />
        <span class="val">&nbsp;</span>
      </div>
    </div>
  </div>

  <div class="col panel">
    <h3>Telemetry</h3>
    <div class="kv" id="kv">
      <div>FPS</div><div id="fps">–</div>
      <div>Right state</div><div id="fsmR">–</div>
      <div>Left state</div><div id="fsmL">–</div>
      <div>NormDist</div><div id="norm">–</div>
      <div>Palm angle</div><div id="pg">–</div>
      <div>SpecCancel%</div><div id="specCancel">–</div>
      <div>Down Latency (mean ms)</div><div id="lat">–</div>
      <div>Downs</div><div id="downs">0</div>
      <div>Ups</div><div id="ups">0</div>
    </div>
    <p class="mini">URL flags: <code>?autostart</code> <code>?disableSpec</code> <code>?disablePalm</code> <code>?fixedSpan=0.08</code></p>
  </div>
</div>

<div class="row">
  <div class="col panel">
    <h3>Virtual keyboard</h3>
    <div class="kbd" id="kbd">
      <div class="key right" data-key="Z" title="Right hand → key Z (MIDI C4)">Z <span class="note">C4</span></div>
      <div class="key left"  data-key="X" title="Left hand → key X (MIDI D4)">X <span class="note">D4</span></div>
    </div>
    <p class="mini">Keys light up on <span class="hint" title="pinch:down">down</span>, stay lit during <span class="hint" title="pinch:hold">hold</span>, and release on <span class="hint" title="pinch:up">up</span>. KeyboardEvents are in‑page only; use WebMIDI for sound.</p>
  </div>
</div>

<div class="row">
  <div class="col panel">
    <h3>Debug (per hand)</h3>
    <div class="grid2">
      <div>
        <div class="kv">
          <div><strong>Right</strong></div><div></div>
          <div>Index raw</div><div id="r_ix_raw">-</div>
          <div>Index smooth</div><div id="r_ix_sm">-</div>
          <div>Thumb raw</div><div id="r_tx_raw">-</div>
          <div>Thumb smooth</div><div id="r_tx_sm">-</div>
          <div>Norm (raw/sm)</div><div id="r_norms">-</div>
          <div>Palm angle</div><div id="r_ang">-</div>
          <div>Gate</div><div id="r_gate">-</div>
          <div>Hysteresis</div><div><canvas id="r_hyst" width="240" height="20"></canvas></div>
        </div>
      </div>
      <div>
        <div class="kv">
          <div><strong>Left</strong></div><div></div>
          <div>Index raw</div><div id="l_ix_raw">-</div>
          <div>Index smooth</div><div id="l_ix_sm">-</div>
          <div>Thumb raw</div><div id="l_tx_raw">-</div>
          <div>Thumb smooth</div><div id="l_tx_sm">-</div>
          <div>Norm (raw/sm)</div><div id="l_norms">-</div>
          <div>Palm angle</div><div id="l_ang">-</div>
          <div>Gate</div><div id="l_gate">-</div>
          <div>Hysteresis</div><div><canvas id="l_hyst" width="240" height="20"></canvas></div>
        </div>
      </div>
    </div>
    <p class="mini">Enter tick is solid; Exit tick is dashed. Marker turns green when gated OK.</p>
  </div>
</div>

<footer>
  <span class="pill ok">Hex‑ready ports</span> <span class="pill warn">Demo‑only KeyEvents</span> <span class="pill bad">Allow camera</span>
  <div class="mini">Modular monolith with clean seams → split into hexagonal adapters later. Golden JSONL supports CI parity.</div>
</footer>

<script type="module">
// =========================
// QUERY & HELPERS
// =========================
const Q = new URLSearchParams(location.search);
const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
const median = arr => { const a=[...arr].sort((x,y)=>x-y); const m=a.length>>1; return a.length? (a.length%2?a[m]:(a[m-1]+a[m])/2):0; };
const fmt = (n, p=2)=> (typeof n==='number' ? n.toFixed(p) : '–');

class RollingMedian {
  constructor(n){ this.n=n; this.buf=[]; }
  push(x){ this.buf.push(x); if(this.buf.length>this.n) this.buf.shift(); return median(this.buf); }
  get med(){ return median(this.buf); }
}

// OneEuro filter
class OneEuro {
  constructor({minCutoff=1.0, beta=0.01, dCutoff=1.0}={}){ this.minCutoff=minCutoff; this.beta=beta; this.dCutoff=dCutoff; this.xPrev=null; this.dxPrev=0; this.tPrev=null; }
  static alpha(cutoff, dt){ const r=2*Math.PI*cutoff*dt; return r/(r+1); }
  filter(x, t){ if(this.tPrev==null){ this.tPrev=t; this.xPrev=x; return x; }
    const dt=Math.max(1e-3,(t-this.tPrev)/1000); const dx=(x-this.xPrev)/dt; const aD=OneEuro.alpha(this.dCutoff,dt); const dxHat=aD*dx+(1-aD)*this.dxPrev; const cutoff=this.minCutoff+this.beta*Math.abs(dxHat); const aX=OneEuro.alpha(cutoff,dt); const xHat=aX*x+(1-aX)*this.xPrev; this.tPrev=t; this.xPrev=xHat; this.dxPrev=dxHat; return xHat; }
}

// PubSub
class Emitter { constructor(){ this.s=new Set(); } on(h){ this.s.add(h); return ()=>this.s.delete(h); } emit(e){ this.s.forEach(h=>h(e)); } }

// Persisted spans per hand
function saveSpan(hand, span){ try{ localStorage.setItem('tectangle.span.'+hand, String(span)); }catch{} }
function loadSpan(hand){ try{ const v=localStorage.getItem('tectangle.span.'+hand); return v? +v : null; }catch{ return null; } }

// =========================
// TELEMETRY
// =========================
const Telemetry = (()=>{
  const rec = { downs:0, ups:0, spec:0, specCancel:0, downLat:[], frames:0 };
  let lastDownT=null;
  return {
    noteFrame(){ rec.frames++; },
    noteDown(t, speculative){ if(speculative) rec.spec++; rec.downs++; lastDownT=t; },
    noteUp(t){ rec.ups++; if(lastDownT!=null){ const d=t-lastDownT; if(d>=0 && d<2000) rec.downLat.push(d); }},
    noteSpecCancel(){ rec.specCancel++; },
    snapshot(){ return { downs:rec.downs, ups:rec.ups, specCancelRate: rec.spec? (rec.specCancel/Math.max(1,rec.spec)) : 0, meanDownLatency: rec.downLat.length? Math.round(rec.downLat.reduce((a,b)=>a+b,0)/rec.downLat.length) : 0, frames: rec.frames }; }
  };
})();

// =========================
// MIDI & AUDIO
// =========================
class MidiOut { constructor(){ this.out=null; } async init(){ try{ const access=await navigator.requestMIDIAccess(); this.out=[...access.outputs.values()][0]||null; }catch{} } send(status,data1,data2){ if(this.out) this.out.send([status,data1,data2]); } }
class Beeper { constructor(){ this.ctx=null; this.osc=null; this.gain=null; } ensure(){ if(!this.ctx){ this.ctx=new (window.AudioContext||window.webkitAudioContext)(); } } down(){ this.ensure(); if(this.osc) return; this.osc=this.ctx.createOscillator(); this.gain=this.ctx.createGain(); this.osc.frequency.value=440; this.gain.gain.value=0.1; this.osc.connect(this.gain).connect(this.ctx.destination); this.osc.start(); } up(){ if(this.osc){ this.osc.stop(); this.osc.disconnect(); this.gain.disconnect(); this.osc=null; this.gain=null; } } }

// =========================
// GOLDEN TRACE
// =========================
class GoldenRecorder { constructor(){ this.lines=[]; this.started=false; } start(meta){ if(this.started) return; this.started=true; this.lines.push(JSON.stringify({meta})); } frame(obj){ if(!this.started) return; this.lines.push(JSON.stringify(obj)); } download(){ const blob=new Blob([this.lines.join('\n')+'\n'],{type:'application/jsonl'}); const url=URL.createObjectURL(blob); const a=Object.assign(document.createElement('a'),{href:url,download:`pinch_golden_${new Date().toISOString().replace(/[:.]/g,'-')}.jsonl`}); document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); } }

// =========================
// PINCH CORE
// =========================
function createPinchFeature(cfg={}){
  const dom = { cone: byId('cone'), enter: byId('enter'), exit: byId('exit'), minCutoff: byId('minCutoff'), beta: byId('beta'), dCutoff: byId('dCutoff'), palmGate: byId('palmGate'), speculative: byId('speculative') };
  const C = Object.assign({
    palmConeDeg: +dom.cone.value || 30,
    enterThresh: +dom.enter.value || 0.30,
    exitThresh:  +dom.exit.value  || 0.42,
    enterDebounceMs: 40, exitDebounceMs: 40,
    holdTimeoutMs: 500, autoReleaseMs: 5000,
    enableTOI: !Q.has('disableTOI'), enableSpeculative: !Q.has('disableSpec') && dom.speculative.checked,
    palmGate: !Q.has('disablePalm') && dom.palmGate.checked,
    oneEuro: { minCutoff:+dom.minCutoff.value, beta:+dom.beta.value, dCutoff:+dom.dCutoff.value }
  }, cfg);

  const emitter = new Emitter();
  let state='Idle', lastDown=0, speculative=false, holdTimer=0;
  const filt = { ix:new OneEuro(C.oneEuro), iy:new OneEuro(C.oneEuro), iz:new OneEuro(C.oneEuro), tx:new OneEuro(C.oneEuro), ty:new OneEuro(C.oneEuro), tz:new OneEuro(C.oneEuro) };
  const medV = new RollingMedian(30), medA = new RollingMedian(30);
  let lastNorm=null, lastT=null, vRel=0, aRel=0, vRelPrev=0;

  function palmAngle(wrist, indexMCP, pinkyMCP){
    if(!wrist || !indexMCP || !pinkyMCP) return null;
    const vx=indexMCP[0]-wrist[0], vy=indexMCP[1]-wrist[1], vz=(indexMCP[2]??0)-(wrist[2]??0);
    const ux=pinkyMCP[0]-wrist[0], uy=pinkyMCP[1]-wrist[1], uz=(pinkyMCP[2]??0)-(wrist[2]??0);
    const nx=vy*uz - vz*uy, ny=vz*ux - vx*uz, nz=vx*uy - vy*ux; // normal = v x u
    const nzNorm=Math.hypot(nx,ny,nz)||1; const cos=(-nz)/nzNorm; // facing camera (-Z)
    return Math.acos(clamp(cos,-1,1))*180/Math.PI;
  }

  function palmOk(wrist, indexMCP, pinkyMCP){
    if(!C.palmGate) return true;
    if(!wrist || !indexMCP || !pinkyMCP) return true; // forgive missing
    const ang = palmAngle(wrist, indexMCP, pinkyMCP);
    return ang==null ? true : (ang <= C.palmConeDeg);
  }

  function update(frame){
    const t=frame.t;
    // raw coords
    const ixRaw=frame.indexTip[0], iyRaw=frame.indexTip[1], izRaw=frame.indexTip[2]||0;
    const txRaw=frame.thumbTip[0], tyRaw=frame.thumbTip[1], tzRaw=frame.thumbTip[2]||0;
    // smoothed coords
    const ix=filt.ix.filter(ixRaw,t), iy=filt.iy.filter(iyRaw,t), iz=filt.iz.filter(izRaw,t);
    const tx=filt.tx.filter(txRaw,t), ty=filt.ty.filter(tyRaw,t), tz=filt.tz.filter(tzRaw,t);

    let kn = Q.get('fixedSpan')? +Q.get('fixedSpan') : loadSpan(frame.hand);
    if(!kn && frame.indexMCP && frame.pinkyMCP){ kn = Math.hypot(frame.indexMCP[0]-frame.pinkyMCP[0], frame.indexMCP[1]-frame.pinkyMCP[1]); }
    if(!kn) kn=0.08; // normalized fallback

    const rawDist = Math.hypot(ixRaw-txRaw, iyRaw-tyRaw); const rawNorm=rawDist/kn;
    const smDist = Math.hypot(ix-tx, iy-ty); const norm=smDist/kn;
    if(lastNorm!=null){ const dt=Math.max(1,(t-lastT)); vRel=(norm-lastNorm)/(dt/1000); medV.push(Math.abs(vRel)); }
    if(lastT!=null){ const dt=Math.max(1,(t-lastT)); aRel=(vRel - vRelPrev)/(dt/1000); medA.push(Math.abs(aRel)); }
    vRelPrev = vRel;
    lastNorm=norm; lastT=t;

    const kinOk = Math.abs(vRel) < 3*(medV.med||1)+3 && Math.abs(aRel) < 5*(medA.med||1)+5;
    const ang = palmAngle(frame.wrist, frame.indexMCP, frame.pinkyMCP);
    HUD.setPalmAngle?.(frame.hand, ang);
    const gatePalm = palmOk(frame.wrist, frame.indexMCP, frame.pinkyMCP);
    const gate  = gatePalm && kinOk;

    const TOI = vRel<0 ? (norm/Math.abs(vRel))*1000 : Infinity; // ms
    const allowSpec = C.enableSpeculative && gate && TOI<120 && TOI>-40;

    switch(state){
      case 'Idle':
        if(gate && norm < C.enterThresh){
          if(allowSpec){ speculative=true; emitter.emit({type:'pinch:down', t, speculative:true}); Telemetry.noteDown(t, true); }
          state='PrePinch'; lastDown=t; holdTimer=t;
        }
        break;
      case 'PrePinch':
        if(!gate){ if(speculative){ Telemetry.noteSpecCancel(); } speculative=false; state='Idle'; break; }
        if(norm < C.enterThresh){ if(!speculative){ emitter.emit({type:'pinch:down', t}); Telemetry.noteDown(t, false);} speculative=false; state='Pinched'; }
        else if(t - lastDown > 120){ if(speculative){ Telemetry.noteSpecCancel(); } speculative=false; state='Idle'; }
        break;
      case 'Pinched':
        // Optional hold tick every ~200ms
        if (t - holdTimer > 200){ emitter.emit({ type:'pinch:hold', t, dur: t - lastDown }); holdTimer = t; }
        if(norm > C.exitThresh){ state='ReleasePending'; }
        if(t - lastDown > C.autoReleaseMs){ emitter.emit({type:'pinch:up', t}); Telemetry.noteUp(t); state='Idle'; }
        break;
      case 'ReleasePending':
        if(norm > C.exitThresh){ emitter.emit({type:'pinch:up', t}); Telemetry.noteUp(t); state='Idle'; }
        else state='Pinched';
        break;
    }

    HUD.updateRuntime({ norm, gate, fps: FPS.tick(t) });
    HUD.debugUpdate?.(frame.hand, { ixRaw, iyRaw, txRaw, tyRaw, ixSm:ix, iySm:iy, txSm:tx, tySm:ty, rawNorm, norm, gate, ang, enter:C.enterThresh, exit:C.exitThresh });
    Golden.frame({ t, norm: +norm.toFixed(4), state, gate });
  }

  return { update, on: h=>emitter.on(h) };
}

// =========================
// HUD & FPS
// =========================
function byId(id){ return document.getElementById(id); }
const HUD = (()=>{
  const el = { fps: byId('fps'), fsmR: byId('fsmR'), fsmL: byId('fsmL'), norm: byId('norm'), pg: byId('pg'), lat: byId('lat'), downs: byId('downs'), ups: byId('ups'), specCancel: byId('specCancel'), status: byId('status'), enterOut: byId('enterOut'), exitOut: byId('exitOut'), coneOut: byId('coneOut'), minCutoffOut: byId('minCutoffOut'), betaOut: byId('betaOut'), dCutoffOut: byId('dCutoffOut') };
  return {
    status(msg){ el.status.textContent = msg; },
    setPalmAngle(ang){ el.pg.textContent = (ang|0)+'°'; },
    updateRuntime({norm, gate, fps}){
      el.norm.textContent = typeof norm==='number' ? norm.toFixed(3) : '–';
      el.fps.textContent  = fps? fps.toFixed(1):'–';
      const s = Telemetry.snapshot();
      el.lat.textContent  = s.meanDownLatency||'–'; el.downs.textContent=s.downs; el.ups.textContent=s.ups; el.specCancel.textContent=(s.specCancelRate*100).toFixed(1)+'%';
    },
    setState(hand, state){ if(hand==='Right') el.fsmR.textContent = state; else el.fsmL.textContent = state; },
    syncOutputs(){ el.enterOut.textContent = (+byId('enter').value).toFixed(2); el.exitOut.textContent = (+byId('exit').value).toFixed(2); el.coneOut.textContent = (+byId('cone').value).toFixed(0)+'°'; el.minCutoffOut.textContent = (+byId('minCutoff').value).toFixed(1); el.betaOut.textContent = (+byId('beta').value).toFixed(3); el.dCutoffOut.textContent = (+byId('dCutoff').value).toFixed(1); }
  };
})();
const FPS = (()=>{ let lastT=null, fps=null; return { tick(t){ if(lastT!=null){ const dt=(t-lastT)/1000; fps = clamp(1/dt,0,240); } lastT=t; return fps; } };})();

// Patch HUD helpers: richer palm angle + debugUpdate + degree symbol
try {
  HUD.setPalmAngle = function(hand, ang){ if(typeof ang==='number'){ const pg = document.getElementById('pg'); if(pg) pg.textContent = (ang|0)+'°'; const side = hand==='Left'?'L':'R'; const id = side==='R' ? 'r_ang' : 'l_ang'; const elAng = document.getElementById(id); if(elAng) elAng.textContent = (ang|0)+'°'; } };
  const oldSync = HUD.syncOutputs;
  HUD.syncOutputs = function(){ if(oldSync) oldSync(); const coneOut = document.getElementById('coneOut'); if(coneOut){ coneOut.textContent = (+document.getElementById('cone').value).toFixed(0)+'°'; } };
  HUD.debugUpdate = function(hand, d){ const side = hand==='Left'?'L':'R'; const id = s=> (side==='R'? 'r_'+s : 'l_'+s); const setText=(k,v)=>{ const el=document.getElementById(id(k)); if(el) el.textContent=v; }; const pair=(a,b)=> (typeof a==='number' && typeof b==='number') ? `${a.toFixed(3)}, ${b.toFixed(3)}` : '�?"'; setText('ix_raw', pair(d.ixRaw, d.iyRaw)); setText('ix_sm', pair(d.ixSm, d.iySm)); setText('tx_raw', pair(d.txRaw, d.tyRaw)); setText('tx_sm', pair(d.txSm, d.tySm)); setText('norms', `${d.rawNorm.toFixed(3)} / ${d.norm.toFixed(3)}`); setText('gate', d.gate? 'OK':'×'); const c=document.getElementById(id('hyst')); if(c){ const ctx=c.getContext('2d'); const w=c.width, h=c.height; ctx.clearRect(0,0,w,h); ctx.save(); ctx.fillStyle='#0b111a'; ctx.fillRect(0,0,w,h); const x=Math.max(0,Math.min(1,d.norm))*w; const xe=Math.max(0,Math.min(1,d.enter))*w; const xx=Math.max(0,Math.min(1,d.exit))*w; ctx.strokeStyle='#82d4ff'; ctx.beginPath(); ctx.moveTo(xe,0); ctx.lineTo(xe,h); ctx.stroke(); ctx.setLineDash([4,3]); ctx.strokeStyle='#ffd47a'; ctx.beginPath(); ctx.moveTo(xx,0); ctx.lineTo(xx,h); ctx.stroke(); ctx.setLineDash([]); ctx.fillStyle = d.gate? '#20c997' : '#5a7086'; ctx.beginPath(); ctx.arc(x,h/2,4,0,Math.PI*2); ctx.fill(); ctx.restore(); } };
} catch {}

// =========================
// OVERLAY
// =========================
const Overlay = (()=>{
  const canvas = byId('overlay'); const g = canvas.getContext('2d');
  function clear(){ g.clearRect(0,0,canvas.width,canvas.height); }
  function drawHands(hands){ const draw = byId('drawLandmarks'); if(draw && !draw.checked) return; if(!hands||!hands.length) return; g.save(); g.lineWidth=2; hands.forEach((lm, idx)=>{ const colorStroke = idx===0 ? '#2a87ff' : '#93d977'; const colorFill = idx===0 ? '#82d4ff' : '#b7f5a1'; g.strokeStyle=colorStroke; g.fillStyle=colorFill; for(const p of lm){ g.beginPath(); g.arc(p[0]*canvas.width, p[1]*canvas.height, 3,0,Math.PI*2); g.fill(); } const it=lm[8], tt=lm[4]; if(it && tt){ g.beginPath(); g.moveTo(it[0]*canvas.width, it[1]*canvas.height); g.lineTo(tt[0]*canvas.width, tt[1]*canvas.height); g.stroke(); } }); g.restore(); }
  function annotate(text){ g.save(); g.fillStyle='rgba(0,0,0,.4)'; g.fillRect(8,8,280,68); g.fillStyle='#e7edf3'; g.font='12px system-ui'; const lines=text.split('\n'); lines.forEach((ln,i)=> g.fillText(ln, 16, 28+i*16)); g.restore(); }
  return { clear, drawHands, annotate };
})();

// =========================
// MEDIAPIPE ADAPTER
// =========================
function createMediaPipeSource(video, onFrame){
  let landmarker=null; let rafId=null; let running=false; let lastHands=null;
  async function init(){
    const vision = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.19/vision_bundle.mjs');
    const { FilesetResolver, HandLandmarker } = vision;
    const fileset = await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.19/wasm');
    landmarker = await HandLandmarker.createFromOptions(fileset, {
      baseOptions: { modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task' },
      runningMode: 'VIDEO', numHands: 2
    });
  }
  const toArr = lm => [lm.x, lm.y, lm.z ?? 0];
  function loop(){ if(!running) return; const t=performance.now(); try { const res = landmarker.detectForVideo(video, t); const L = res?.landmarks || []; lastHands = L.length ? L.map(hand => hand.map(toArr)) : null; for (let i=0;i<L.length;i++){ const h=L[i]; if(!h || h.length<21) continue; let handTag='Right'; const hs=res?.handednesses?.[i]?.[0]; if(hs && hs.categoryName) handTag = hs.categoryName; onFrame({ t, hand:(handTag==='Left'?'Left':'Right'), indexTip:toArr(h[8]), thumbTip:toArr(h[4]), wrist:toArr(h[0]), indexMCP:toArr(h[5]), pinkyMCP:toArr(h[17]) }); } } catch(e){} rafId=requestAnimationFrame(loop); }
  return { async start(){ if(running) return; await init(); running=true; loop(); }, stop(){ running=false; if(rafId) cancelAnimationFrame(rafId); }, getLastLandmarks(){ return lastHands; } };
}

// =========================
// CALIBRATION
// =========================
function runCalibration(getHands){ return new Promise(async (resolve)=>{ alert('Calibration: Hold one hand, open/close slowly for ~3 seconds.'); const samples=[]; const start=performance.now(); while(performance.now()-start < 3200){ const hands=getHands?.(); const lm = hands && hands[0]; if(lm && lm.length>=21){ const kn=Math.hypot(lm[5][0]-lm[17][0], lm[5][1]-lm[17][1]); samples.push(kn); } await new Promise(r=>requestAnimationFrame(r)); } const span=median(samples)||0.08; alert('Knuckle span = '+span.toFixed(4)); resolve(span); }); }

// =========================
// ORCHESTRATOR
// =========================
const video = byId('cam'); const status = byId('status'); const startStop = byId('startStop'); const btnCalib = byId('calibrate'); const btnDownload = byId('download'); const btnLoadVideo = document.getElementById('loadVideo'); const inputVideo = document.getElementById('videoFile');
const Golden = new GoldenRecorder(); const midi = new MidiOut(); const beeper = new Beeper();
let mp=null, cores=new Map(); // hand -> { core, unsub, lastDown }

window.addEventListener('unhandledrejection', e=>{ console.error('Unhandled rejection', e.reason); HUD.status('error (recovered)'); });

function handMapping(hand){ return hand==='Left' ? { key:'X', note:62 } : { key:'Z', note:60 }; }

function highlightKey(key, mode){ const el=document.querySelector(`.key[data-key="${key}"]`); if(!el) return; el.classList.toggle('down', mode==='down' || mode==='hold'); el.classList.toggle('hold', mode==='hold'); }

function handlePinchEvent(hand, e){ const map=handMapping(hand); const useMidi = byId('midi').checked; if(e.type==='pinch:down'){ document.dispatchEvent(new KeyboardEvent('keydown',{ key:map.key, bubbles:true })); if(byId('beep').checked) beeper.down(); if(useMidi) midi.send(0x90, map.note, 100); highlightKey(map.key,'down'); Golden.frame({ t:e.t, event:'down', hand, spec:!!e.speculative }); } else if(e.type==='pinch:hold'){ highlightKey(map.key,'hold'); } else if(e.type==='pinch:up'){ document.dispatchEvent(new KeyboardEvent('keyup',{ key:map.key, bubbles:true })); if(byId('beep').checked) beeper.up(); if(useMidi) midi.send(0x80, map.note, 0); highlightKey(map.key,'up'); Golden.frame({ t:e.t, event:'up', hand }); } }

async function start(){ try{ const stream=await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'user' }, audio:false }); video.srcObject=stream; await video.play(); }catch(e){ alert('Camera permission required.'); throw e; }
  mp = createMediaPipeSource(video, f=>{ Telemetry.noteFrame(); if(!cores.has(f.hand)){ const c=createPinchFeature(); const unsub=c.on(e=>{ handlePinchEvent(f.hand, e); HUD.setState(f.hand, e.type.replace('pinch:','')); }); cores.set(f.hand,{ core:c, unsub:null }); cores.get(f.hand).unsub = c.on(e=>{}); } const entry=cores.get(f.hand); entry.core.update(f); Overlay.clear(); Overlay.drawHands(mp.getLastLandmarks()); Overlay.annotate(`enter: ${(+byId('enter').value).toFixed(2)}  exit: ${(+byId('exit').value).toFixed(2)}  cone: ${(+byId('cone').value).toFixed(0)}°`); }); await mp.start(); await midi.init(); HUD.status('running'); Golden.start({ sha:'demo-local', device:navigator.userAgent, fps:'rAF', cfg:{ enter:+byId('enter').value, exit:+byId('exit').value, cone:+byId('cone').value } }); }

function stop(){ for(const [hand,obj] of cores){ if(obj.unsub) obj.unsub(); } cores.clear(); if(mp) mp.stop(); if(video.srcObject){ video.srcObject.getTracks().forEach(t=>t.stop()); video.srcObject=null; } try{ video.pause(); }catch{} beeper.up(); HUD.status('stopped'); }

// Start from a local video file (offline processing)
async function startVideoFile(file){
  try{
    const url = URL.createObjectURL(file);
    video.srcObject = null; video.src = url; await video.play();
  }catch(e){ alert('Could not play selected video.'); throw e; }
  mp = createMediaPipeSource(video, f=>{
    Telemetry.noteFrame();
    if(!cores.has(f.hand)){
      const c=createPinchFeature(); const unsub=c.on(e=>{ handlePinchEvent(f.hand, e); HUD.setState(f.hand, e.type.replace('pinch:','')); });
      cores.set(f.hand,{ core:c, unsub });
    }
    const entry=cores.get(f.hand); entry.core.update(f);
    Overlay.clear(); Overlay.drawHands(mp.getLastLandmarks());
    Overlay.annotate(`video  enter: ${(+byId('enter').value).toFixed(2)}  exit: ${(+byId('exit').value).toFixed(2)}  cone: ${(+byId('cone').value).toFixed(0)}°`);
  });
  await mp.start(); await midi.init(); HUD.status('running (video)');
  Golden.start({ sha:'demo-local', device:'video-file', fps:'rAF', cfg:{ enter:+byId('enter').value, exit:+byId('exit').value, cone:+byId('cone').value } });
  video.onended = ()=>{ stop(); };
}

startStop.addEventListener('change', ()=>{ startStop.checked ? start() : stop(); });
btnCalib.addEventListener('click', async ()=>{ if(!mp){ alert('Start camera first.'); return; } const span = await runCalibration(()=> mp.getLastLandmarks()); const url = new URL(location.href); url.searchParams.set('fixedSpan', String(span)); history.replaceState(null,'',url); saveSpan('Right', span); /* quick path; run twice for Left too if desired */ });
btnDownload.addEventListener('click', ()=> Golden.download());
if(btnLoadVideo && inputVideo){
  btnLoadVideo.addEventListener('click', ()=> inputVideo.click());
  inputVideo.addEventListener('change', async (e)=>{ const f=e.target.files?.[0]; if(!f) return; stop(); await startVideoFile(f); });
}

function bindRange(id, out){ const el=byId(id); const o=byId(out); const sync=()=>{ HUD.syncOutputs(); rebuildCores(); }; el.addEventListener('input', sync); }
function rebuildCores(){ for(const [hand,obj] of cores){ // unsubscribe and rebuild
    const c=createPinchFeature(); const unsub=c.on(e=>{ handlePinchEvent(hand, e); HUD.setState(hand, e.type.replace('pinch:','')); }); cores.set(hand,{ core:c, unsub }); }
}
['enter','exit','cone','minCutoff','beta','dCutoff'].forEach(id=> bindRange(id, id+'Out'));
HUD.syncOutputs();

// Auto-start if ?autostart
if(Q.has('autostart')){ byId('startStop').checked=true; start(); }

HUD.status('ready');

// --- Headless CI replay hook ---
window.__replayGolden = async function(frames){ if(!cores.has('Right')){ const c=createPinchFeature(); const unsub = c.on(e=>handlePinchEvent('Right',e)); cores.set('Right',{ core:c, unsub }); } const c=cores.get('Right').core; for(const f of frames){ if(f && typeof f.t==='number' && typeof f.norm==='number'){ const ix = 0.5 + f.norm/2, tx = 0.5 - f.norm/2; c.update({ t:f.t, hand:'Right', indexTip:[ix,0.5,0], thumbTip:[tx,0.5,0], indexMCP:[0.4,0.6,0], pinkyMCP:[0.6,0.6,0], wrist:[0.5,0.7,0] }); } await new Promise(r=>setTimeout(r, 16)); } };
window.__getGolden = function(){ try{ return (Golden && Golden.lines) ? [...Golden.lines] : []; }catch{ return []; } };
window.__getTelemetry = function(){ try{ return Telemetry.snapshot(); }catch{ return null; } };
Object.defineProperties(window,{ __pinch:{ get(){ return { cores, start, startVideoFile, stop }; } } });
</script>
</body>
</html>
