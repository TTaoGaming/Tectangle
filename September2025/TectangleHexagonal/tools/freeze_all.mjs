#!/usr/bin/env node
// WEBWAY:ww-2025-031: Hex freeze-all — clone entire Hexagonal tree into archive-stale with timestamp
import { promises as fs } from 'node:fs';
import path from 'node:path';

const ROOT = process.cwd();
const SRC = path.join(ROOT, 'September2025', 'TectangleHexagonal');
const TS = (()=>{
  const iso = new Date().toISOString(); // 2025-09-18T12:34:56.789Z
  const noMs = iso.replace(/\.\d{3}Z$/, 'Z');
  return noMs.replace(/[:]/g, '-'); // 2025-09-18T12-34-56Z
})();
const OUT_ROOT = path.join(ROOT, 'archive-stale', `tectanglehexagonal_freeze_${TS}`);
const DEST = path.join(OUT_ROOT, 'September2025', 'TectangleHexagonal');

async function ensureDir(dir){ await fs.mkdir(dir, { recursive: true }); }

async function copyTree(src, dst){
  await ensureDir(dst);
  // Use Node 18+ fs.cp for reliability
  // If fs.cp is not available, fallback to manual copy
  const anyFs = /** @type {any} */(fs);
  if (typeof anyFs.cp === 'function'){
    await anyFs.cp(src, dst, { recursive: true, force: true });
    return;
  }
  // Fallback: manual recursion
  const entries = await fs.readdir(src, { withFileTypes: true });
  for (const e of entries){
    const s = path.join(src, e.name);
    const d = path.join(dst, e.name);
    if (e.isDirectory()) await copyTree(s, d); else await fs.copyFile(s, d);
  }
}

async function countFiles(dir){
  let n = 0;
  const stack = [dir];
  while (stack.length){
    const cur = stack.pop();
    if (!cur) break;
    try{
      const ents = await fs.readdir(cur, { withFileTypes: true });
      for (const e of ents){
        const p = path.join(cur, e.name);
        if (e.isDirectory()) stack.push(p); else n++;
      }
    }catch{}
  }
  return n;
}

async function write(file, data){
  await ensureDir(path.dirname(file));
  await fs.writeFile(file, data, 'utf8');
}

async function main(){
  // Preconditions
  try{ await fs.access(SRC); } catch{ throw new Error(`Source missing: ${SRC}`); }
  await ensureDir(OUT_ROOT);
  console.log(`[freeze-all] Copying from ${path.relative(ROOT, SRC)} -> ${path.relative(ROOT, DEST)}`);
  await copyTree(SRC, DEST);

  // Manifest and README
  const filesCount = await countFiles(DEST);
  const manifest = {
    id: `tectanglehexagonal_freeze_${TS}`,
    created_utc: TS,
    source: 'September2025/TectangleHexagonal',
    files_count: filesCount,
    notes: 'Full tree freeze for reference/regression.'
  };
  await write(path.join(OUT_ROOT, 'freeze_manifest.json'), JSON.stringify(manifest, null, 2));
  const readme = `# Tectangle Hexagonal — Full Freeze\n\n`+
`Snapshot: ${TS}\n\n`+
`This folder contains a complete copy of \`September2025/TectangleHexagonal\` at the time of freezing.\n`+
`It is intended for reference and regression comparisons. Do not modify; copy elsewhere to iterate.\n\n`+
`Paths:\n- Source: September2025/TectangleHexagonal\n- Dest: ${path.relative(ROOT, DEST)}\n\n`+
`Generated by: September2025/TectangleHexagonal/tools/freeze_all.mjs\n`;
  await write(path.join(OUT_ROOT, 'SNAPSHOT_README.md'), readme);

  console.log(`[freeze-all] Done. Output -> ${path.relative(ROOT, OUT_ROOT)} (files: ${filesCount})`);
}

main().catch((e)=>{ console.error('[freeze-all] ERROR', e); process.exit(1); });
