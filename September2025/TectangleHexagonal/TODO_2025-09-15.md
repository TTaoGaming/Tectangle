<!--
STIGMERGY REVIEW HEADER
Status: Pending verification
Review started: 2025-09-16T19:48-06:00
Expires: 2025-09-23T19:48-06:00 (auto-expire after 7 days)

Checklist:
- [ ] Re-evaluate this artifact against current Hexagonal goals
- [ ] Log decisions in TODO_2025-09-16.md
-->

# TODO — 2025-09-15 (Controller ID, Joint Angles, Ghost stability)

## Session Constraints (Simplifications We Intentionally Enforce Today)

- User keeps both palms generally facing camera (we'll add a palm-orientation cone indicator; outside cone = dim / warning, we ignore angle gates there).
- Two hands only; we ignore >2 or missing-hand edge cases beyond 200 ms memory.
- We ask user to keep hands separated (no deliberate inter-hand occlusion handling yet).
- Primary focus: reliable index↔thumb pinch (detect down / stable / release) with minimal false positives.
- Secondary (observability only): light joint angles for index (MCP/PIP/DIP aggregate flex) + thumb (opposition / IP) + palm span.
- We postpone: full biomechanical fingerprint, complex re-ID, Kalman+Hungarian, multi-hand occlusion logic.

## Adoption Alternatives (Not a Sequence — Pick One Strategy First)

Option A — Pinch Sentinel (Minimal Geometry Layer)
Plain: Add just what pinch needs: index–thumb tip distance, relative velocity (closing vs opening), tiny angle set (index flex aggregate, thumb opposition), palm orientation gate. Emit simple anomaly flags (angle impossible, span too small). No landmark mutation.
Leverage: Fastest path to fewer misfires + immediate HUD clarity. Easiest to tune.
Trade-offs: Doesn’t improve general hand stability or future re-ID signal depth.

Option B — Canonical Pinch Feature Vector
Plain: Build a small normalized feature vector (distance, velocity, 3–5 angles, palm span, orientation cosines) every frame; treat it as the single source for pinch classifier + telemetry. Adds scale/orientation invariance and future-proofs for lightweight ML scoring.
Leverage: Creates reusable data foundation (enables later similarity, adaptive thresholds) without full bone chain cost.
Trade-offs: Slightly more work than A; still no direct smoothing / correction.

Option C — Predictive Pinch State Machine + Micro History
Plain: Maintain a rolling buffer (~120 ms) of pinch features; apply slope + acceleration heuristics to “pre-confirm” a stable pinch earlier and defer release until sustained opening. Integrate anomaly suppression (ignore one-frame spikes) and continuity weighting.
Leverage: Gives most user-perceived stability (feels deliberate, “musical”).
Trade-offs: Requires dependable raw signals (angles & distance) — harder to tune blindly; adds small conceptual complexity.

Recommended Starting Path Today: Option A (Pinch Sentinel) because constraints (stable palm, separated hands) already reduce complexity; fastest to ship useful feedback loop. Keep folder / flags structured so B can wrap A’s outputs (A is a subset). Only jump to C after A’s raw false-positive rate is characterized.

Feature Flags to Introduce:

- FEATURE_HEX_PALM_CONE (palm orientation gating & HUD indicator)
- FEATURE_HEX_PINCH_SENTINEL (Option A core metrics + anomaly flags)
- FEATURE_HEX_PINCH_VECTOR (Option B canonical vector; wraps sentinel)
- FEATURE_HEX_PINCH_PREDICT (Option C predictive state machine)

Guard Metrics (telemetry / HUD quick checks):

- falseDownRate, falseUpRate (manual or scripted clip baseline)
- meanDownLatencyMs, meanUpLatencyMs
- angleJumpMax (deg/frame) — should stay below threshold (e.g. 25°) under Option A
- palmConeOutsideFrames / totalFrames ratio (should be low after coaching)

Revert Path: Remove added feature flags + sentinel module; do not modify existing tracker logic.

Immediate Micro-Tasks (if choosing Option A):

1. Palm orientation cone math (normal from wrist→palm center vs camera forward) + HUD indicator.
2. Pinch sentinel module: compute tip distance, closing/opening velocity, indexFlex, thumbOpposition, span.
3. HUD panel additions: distance, velocity arrow, angles OK?, anomaly badges.
4. Threshold seed values; quick manual tune; log 1–2 JSONL sessions.
5. Record baseline metrics (falseDown, latency) before expanding.

---

Priorities (P1 highest)

- P1 Controller/Hand ID for local multiplayer
- P1 Joint-angle export (index/thumb) + plausibility check scaffold
- P1 Ghost prediction: deflicker on exit/release
- P2 Triple-check pinch classifier (distance/velocity/accel + angle)
- P2 Visualization clarity (plain language HUD)

## Tech tree (plain language — what unlocks what)

- Now (biggest leverage, low risk)
  - Tier‑1 Hand Tracker (NN + inertia + side bias) → stable multi‑user IDs (unlocks 2P routing, per‑seat outputs). Flag: FEATURE_HEX_HAND_TRACKER_T1.
  - Confirm Windows + Smoothing for Pinch → “musical” feel (less jitter, fewer false hits) with tiny latency cost.
- Next (pair with Now if time permits)
  - Angle Plausibility → blocks weird poses; reduces false downs during occlusion/crossing.
  - HUD clarity → makes tuning fast (see velocity/angle/confirm timers visibly).
- Later (when 3+ hands or frequent crossings)
  - Kalman + Hungarian (SORT‑style) → stronger ID in crossings/occlusions (more CPU, more tuning).
  - Kalidokit angles (no IK) → richer angle signals; use if simple angles aren’t enough.
  - Biomech fingerprint (calibration) → re‑ID after long occlusion; requires a short setup step.

## Trade‑offs (in plain words)

- Tier‑1 Tracker vs Kalman+Hungarian
  - T1 is simpler and faster; great up to ~3 hands. Can swap on crossings. Hungarian is stronger but heavier to tune.
- Confirm windows
  - Down confirm ≈ 40 ms; Up confirm ≈ 80 ms: fewer flickers; tiny added latency; feels better for music.
- Angles
  - Cheap gate that catches “impossible” pinches; needs rough thresholds; don’t overfit.
- Kalidokit
  - Powerful for rigs/angles; heavier; keep for later unless simple angles fail.

## Today — batched plan (90–120 min)

- [ ] Implement Tier‑1 hand tracker behind FEATURE_HEX_HAND_TRACKER_T1  
  Who: ports/mediapipe.js + adapters/hand_event_router.mjs  
  How: nearest‑neighbor on wrist with velocity inertia; occlusionMemory=200 ms; maxJump≈0.18; teleport>0.42  
  Output: emit {handId, controllerId}; update hand_id_lab HUD  
  Tests: e2e no‑pinch crossover → teleports<6, reassigns<4, frames>30  
  Note: WEBWAY id ww-2025-001 (see scaffolds/webway_hand-tracker-t1.md)

- [ ] Add confirm windows + debounce to pinch classifier  
  Who: core/pinchCore (keep core pure) + app wiring  
  How: confirmDownMs≈40; confirmUpMs≈80; debounce≈60–100; require toward for down, away for up  
  Keep: OneEuro defaults; optionally add bounded Kalman for norm only (off by default)  
  Gate: normal clip → 1/1 downs/ups; gated clip → 0/0; specCancel ≤ 8–10%

- [ ] Angle plausibility (light)  (Option A core)  
  Who: core util (handGeometry.js) + telemetry/UI  
  How: index MCP flexion; thumb CMC/IP; angle via acos of segment vectors; skip if missing  
  Use: optional gate (warn first, don’t block) — feeds Pinch Sentinel

- [ ] Palm orientation cone indicator (FEATURE_HEX_PALM_CONE)  
  Who: small math util + lab HUD  
  How: derive palm normal (wrist->(indexMCP+pinkyMCP)/2 cross), angle to camera forward; compare to cone threshold (e.g. 40°)  
  Use: if outside cone, HUD dims pinch metrics (avoid false flags)

- [ ] Pinch sentinel module (FEATURE_HEX_PINCH_SENTINEL)  
  Who: core/pinch/pinchSentinel.js  
  How: produce {distance, vDist, indexFlex, thumbOpposition, span, anomalies[]} per frame  
  Use: base for classifier + telemetry; zero external dependencies

- [ ] HUD clarity  
  Show: handId/controllerId, velocity sign (toward/away), confirm timers, angle OK?, spec vs actual counts  
  Why: faster tuning; fewer blind spots

---

Controller ID mapping — H1/H2 → P1/P2 (Design + Acceptance)

Contract (tiny)

- Inputs per frame: zero or more detections with {t, landmarks, side(L/R guess), centroid}.
- Outputs: stable hand instances {handId, firstSeenT, lastSeenT, sideBias, lastPos} and controller events {controllerId, type: down|up|cancel, t}.
- Error modes: occlusion up to 200 ms, crossings, simultaneous first detections, late frames.

Policy

- Hand IDs: first-seen ordering becomes H1, then H2; never renumber during session. Instances expire after >200 ms missing, slot becomes vacant but not recycled unless reset.
- Matching: nearest-neighbor with inertia; maxJump≈0.18; teleport>0.42 => new instance; sideBias aids matching (L/R probability).
- Controller mapping: on first confirmed pinch:down, if P1 empty assign Hx→P1, else if P2 empty assign →P2; freeze until manual reset; do not auto-reassign.
- Ties: simultaneous downs resolve by lower handId (earlier firstSeenT). Expose tie-break rule in telemetry.

Acceptance (guardrails)

- Two-hand sequential clip: stable H1/H2 across entire clip; downs=1, ups=1 per intended hand; no controller reassignments.
- Crossing clip: teleports<6; reassigns<4; frames>30 while IDs remain stable after re-entry within 200 ms.
- HUD shows H1/H2 and P1/P2 badges; Reset clears mappings and instances.

Action checklist (wires + tests)

- [ ] FEATURE_HEX_HAND_TRACKER_T1: new adapter `src/adapters/hand_event_router.mjs` maintains instances and emits per-frame HandEvents.
- [ ] Controller router: assign P1/P2 on confirmed pinch:down; `resetControllerMapping()` API; emit ControllerEvents.
- [ ] Confirm windows in pinch core (Down≈40 ms, Up≈80 ms, debounce≈80) behind flag; require toward/away velocity sign.
- [ ] Telemetry: JSONL stream for {handId lifecycle, teleports, reassigns, controller assignments, tie-breaks}.
- [ ] E2E replays: sequential two-hand clip; crossing/occlusion clip. Assert guard metrics; write counts to JSON.
- [ ] HUD: badges for H/P, Reset button; small indicators for confirm timers and velocity sign.

Notes

- Start simple (T1). Upgrade to batched NN (Hungarian) only when 3+ hands or frequent crossings become common.
- Keep flags: FEATURE_HEX_HAND_TRACKER_T1, FEATURE_HEX_PALM_CONE, FEATURE_HEX_PINCH_SENTINEL to isolate risk and enable fast revert.

## Guardrails + targets

- IDs: teleports<6; reassigns<4 on crossover e2e; tracks live ≤200 ms when occluded.
- Pinch: normal clip → downs=1, ups=1; gated clip → 0/0; specCancel ≤10%; mean down latency 60–200 ms.
- Revert path: feature‑flag blocks; remove FEATURE_HEX_HAND_TRACKER_T1 and WEBWAY markers to roll back.

1. Controller/Hand ID (Tier 1 now; Tier 2 later)

- Who: adapter/router, mediapipe port
- What: Stable handId via NN + inertia + side prior; map to controllerId
- Where: src/adapters/hand_event_router.mjs, src/ports/mediapipe.js, dev/hand_id_lab.html
- When: per frame; 200 ms occlusion memory; maxJump≈0.18; teleport>0.42
- Why: stop ID swaps; unlock 2P local
- How: finalize tracker wiring; emit {handId, controllerId}
- Accept: e2e no‑pinch crossover: teleports<6, reassigns<4, frames>30; manual webcam stable

1. Joint angles (index/thumb) — export + plausibility

- Who: core util (`core/handGeometry.js`), app wiring
- What: Compute MCP/PIP/DIP (index) and CMC/MCP/IP (thumb) angles; expose per frame
- Where: add helpers; surface in telemetry/UI
- When: per frame
- Why: gesture‑invariant feature + plausibility gate
- How: vectors from landmarks; angle via acos; handle missing
- Accept: angles update smoothly; lab HUD shows angles

1. Pinch classifier triple check

- Who: core/pinchCore
- What: distance hysteresis + velocity sign + optional accel + angle gate
- Why: reduce misfires to <2% (98% correct)
- How: start with distance+velocity; add angle plausibility; keep accel optional
- Accept: on normal clip, downs/ups correct; gated clip 0/0; misfires<2%

1. Ghost prediction deflicker (exit stability)

- Who: dev/ghost_hysteresis.html + ports
- What: stabilize ghost up by requiring confirm window (e.g., vRel>0 && norm>mid for ≥confirmUpMs)
- How: small confirmUpMs (≈90 ms); palm stable window optional
- Accept: ghost Δt exit measured; fewer flickers on hold

1. Visualizations & docs

- HUD: show handId/controllerId, angles, vRel/aRel, ghost vs actual
- README: 5W1H notes; calibration stub for biomech fingerprint

## 2025-09-16 Follow-ups
- [ ] Fix `hand_id_lab.html` to consume `window.__hexLastHands` so tracker HUD matches canned lab output.
- [ ] Consolidate tracker labs by folding `hand_tracker_t1_lab.html` into `canned_hand_id_test_prototype.html` and deleting the duplicate.
- [ ] Patch `scripts/p1p2_lockin_run.cjs` to percent-encode served asset URLs and honor the per-hand fallback without failing the run.
- [ ] Add a recurring `tsc --noEmit` (or `// @ts-check`) job so we type-check core/ports on every run.
- [ ] Retire `pinch_flappy.html` once Dino runner bridge is the single canonical arcade demo.
- [ ] Tune ghost predictive hysteresis so the lookahead ring stops flickering around enter/exit.
- [ ] Generalize tracker/controller path for 4 concurrent hands (per-hand OneEuro, handId seats, per-hand telemetry)
- [ ] Update UI/HUD to render per-hand hysteresis + palm angles dynamically from tracker tracks
- [ ] Extend smoke test suite with synthetic 3rd/4th hand fixtures and rerun MP4 replay once left/right path works
