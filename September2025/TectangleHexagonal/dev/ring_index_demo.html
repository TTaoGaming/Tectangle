<!doctype html>
<!--
STIGMERGY REVIEW HEADER
Status: Pending verification
Review started: 2025-09-16T19:32-06:00
Expires: 2025-09-23T19:32-06:00 (auto-expire after 7 days)

Checklist:
- [ ] Launch prototype against current September2025 builds
- [ ] Run associated tests:
  - [ ] tests/unit/pinchCore.test.mjs
  - [ ] tests/unit/fingerGeometryCore.test.mjs
  - [ ] tests/unit/controllerRouterCore.concurrent.test.mjs
- [ ] Capture findings + next steps in docs/TODO_2025-09-16.md
-->

<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Index Ring â€¢ Hex Lattice</title>
  <style>
    :root{ --bg:#0b0d10; --fg:#e7edf3; }
    body{margin:0;background:var(--bg);color:var(--fg);font:14px system-ui}
    header{padding:10px 14px;border-bottom:1px solid #1a222c;background:#0f141a}
    .row{display:flex;gap:12px;padding:12px 16px;flex-wrap:wrap}
    video,canvas{border:1px solid #1a222c;border-radius:12px;background:#0c1117}
    video{width:420px;height:auto}
    canvas{width:640px;height:360px}
  </style>
</head>
<body>
  <header><h3>Index Finger Hex Lattice Ring <small>(tilt and wrap)</small></h3></header>
  <div class="row">
    <video id="cam" playsinline muted autoplay></video>
    <canvas id="overlay" width="640" height="360"></canvas>
  </div>
  <script type="module">
    import { createMediaPipeSource } from '../src/ports/mediapipe.js';
    import { createHexLatticeRingRenderer } from '../src/adapters/hex_lattice_ring_renderer.mjs';

    const video = document.getElementById('cam');
    const canvas = document.getElementById('overlay');
    const rr = createHexLatticeRingRenderer(canvas);

    // Camera
    async function startCam(){
      const s = await navigator.mediaDevices.getUserMedia({ video:{ width:{ideal:1280}, height:{ideal:720} }, audio:false });
      video.srcObject = s; await video.play();
      const mp = createMediaPipeSource(video, onHandFrame);
      await mp.start();
    }

    function onHandFrame(f){
      const lm = f.landmarks; if(!lm || lm.length<21) return;
      // Index finger: tip(8), PIP(6), DIP(7), MCP(5). Use PIP-DIP to estimate thickness and direction.
      const tip = lm[8], dip = lm[7], pip = lm[6]; // [x,y,z] in normalized image space
      // Project to canvas pixels
      const px = v=> ({ x: v[0]*canvas.width, y: v[1]*canvas.height, z: v[2]||0 });
      const tipP = px(tip), dipP = px(dip), pipP = px(pip);

      // Finger axis (approx): pip->tip
      const ax = tipP.x - pipP.x, ay = tipP.y - pipP.y; const axisLen = Math.hypot(ax,ay)||1;
      const axisAngle = Math.atan2(ay, ax);

      // Thickness estimate: distance between pip and dip (image proxy)
      const thick = Math.hypot(dipP.x - pipP.x, dipP.y - pipP.y);

      // Ring ellipse radii: major follows finger circumference proxy; minor scaled by depth (z)
      const R = Math.max(18, thick*3.2); // major radius (wrap diameter proxy)
      const depth = Math.min(0.08, Math.max(-0.08, tipP.z)); // clamp small range
      const r = Math.max(10, R * (0.55 - depth*4)); // minor radius shrinks with negative z (toward camera)

      // Ring center a bit behind tip along finger axis (toward hand) for visual wrap
      const cx = tipP.x - Math.cos(axisAngle)* (thick*2.2);
      const cy = tipP.y - Math.sin(axisAngle)* (thick*2.2);

      rr.clear();
      rr.draw({ center:{x:cx,y:cy}, R, r, rot: axisAngle, color:'#93d977', hexR: Math.max(3, thick*0.6), density: 72 });
    }

    startCam();
  </script>
</body>
</html>
