<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Google Hand Landmarker (Offline)</title>
  <style>
    html,body{height:100%;margin:0}
    body{background:#000;color:#e5e7eb;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    #wrap{position:fixed;inset:0;display:grid;place-items:center}
    #view{position:relative;width:min(100vw,100vh*4/3);height:min(100vh,100vw*3/4);background:#000}
    video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover}
    #ui{position:fixed;left:10px;top:10px;display:flex;gap:8px;align-items:center}
    button{background:#16a34a;color:white;border:0;border-radius:8px;padding:6px 10px;cursor:pointer}
  </style>
</head>
<body>
  <div id="wrap">
    <div id="view">
      <video id="video" playsinline autoplay muted></video>
      <canvas id="canvas"></canvas>
    </div>
  </div>
  <div id="ui">
    <button id="btnStart">Start</button>
    <button id="btnStop" style="background:#ef4444">Stop</button>
  </div>

  <script type="module">
    // Minimal offline replica of Google's Hand Landmarker example (no network)
    const nmBase = '/node_modules/@mediapipe/tasks-vision';
    const wasmBase = `${nmBase}/wasm`;
    const HAND_MODEL = '/September2025/TectangleHexagonal/assets/models/hand_landmarker.task';

    const q = new URLSearchParams(location.search);
    const WANT_FS = (q.get('fs')==='1');

    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const g = canvas.getContext('2d');
    const btnStart = document.getElementById('btnStart');
    const btnStop = document.getElementById('btnStop');

    let landmarker; let running=false; let stream; let lastTs=0;

    function resize(){ const r = video.getBoundingClientRect(); canvas.width = Math.max(2, r.width|0); canvas.height = Math.max(2, r.height|0); }
    window.addEventListener('resize', resize);
    video.addEventListener('loadedmetadata', resize);
    video.addEventListener('play', resize);

    async function start(){
      try{
        stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode:'user', width:{ideal:640}, height:{ideal:480} }, audio:false });
        video.srcObject = stream; await video.play(); running=true; if(WANT_FS){ const el=document.documentElement; try{ await el.requestFullscreen?.(); }catch{} }
        loop();
      }catch(e){ console.error(e); }
    }
    function stop(){ try{ running=false; video.pause(); stream?.getTracks()?.forEach(t=>t.stop()); }catch{} }
    btnStart.addEventListener('click', start);
    btnStop.addEventListener('click', stop);

    let filesetResolver;
    (async ()=>{
      const vision = await import(`${nmBase}/vision_bundle.mjs`);
      const { FilesetResolver, HandLandmarker } = vision;
      filesetResolver = await FilesetResolver.forVisionTasks(wasmBase);
      landmarker = await HandLandmarker.createFromOptions(filesetResolver, {
        baseOptions: { modelAssetPath: HAND_MODEL },
        runningMode: 'VIDEO',
        numHands: 2
      });
    })().catch(e=> console.error('offline import failed', e));

    async function loop(){
      while(running){
        try{
          const ts = performance.now();
          if(!landmarker){ await new Promise(r=>setTimeout(r, 30)); continue; }
          const res = await landmarker.detectForVideo(video, ts);
          draw(res);
          await new Promise(r=>setTimeout(r, 16));
        }catch(e){ console.error(e); await new Promise(r=>setTimeout(r, 32)); }
      }
    }

    // Simple connector set (matches Mediapipe Hands)
    const EDGES = [
      [0,1],[1,2],[2,3],[3,4],          // thumb
      [0,5],[5,6],[6,7],[7,8],          // index
      [5,9],[9,10],[10,11],[11,12],     // middle
      [9,13],[13,14],[14,15],[15,16],   // ring
      [13,17],[0,17],[17,18],[18,19],[19,20] // pinky + palm
    ];
    function draw(res){
      const W = canvas.width|0, H = canvas.height|0; g.clearRect(0,0,W,H);
      const hands = res?.landmarks || [];
      const handsLR = res?.handednesses || [];
      for(let i=0;i<hands.length;i++){
        const lm = hands[i];
        const handed = handsLR?.[i]?.[0]?.categoryName || '';
        const stroke = handed==='Right' ? '#34d399' : '#22d3ee';
        // connectors
        g.strokeStyle = stroke; g.lineWidth = 2; g.beginPath();
        for(const [a,b] of EDGES){ const pa = lm[a], pb = lm[b]; if(!pa||!pb) continue; g.moveTo(pa.x*W, pa.y*H); g.lineTo(pb.x*W, pb.y*H); }
        g.stroke();
        // keypoints
        g.fillStyle = stroke;
        for(const p of lm){ g.beginPath(); g.arc(p.x*W, p.y*H, 2.2, 0, Math.PI*2); g.fill(); }
        // handedness label near wrist (0)
        const w0 = lm[0]; if(w0){ g.fillStyle = 'rgba(255,255,255,0.9)'; g.font = '12px system-ui,Segoe UI,Roboto,Helvetica,Arial'; g.fillText(handed||'', w0.x*W+6, w0.y*H-6); }
      }
    }
  </script>
</body>
</html>
