<!doctype html>
<!--
STIGMERGY REVIEW HEADER
Status: LEGACY / FAILED (superseded by v2 prototype)  
Decision: Preserve for reference; do not extend.  
Review started: 2025-09-16T19:32-06:00
Superseded: 2025-09-16TXX:XX-06:00 (v2 scaffold init)  
Expires: 2025-09-23T19:32-06:00 (auto-expire after 7 days)

LEGACY NOTES:
- This version experienced visualization + telemetry coupling issues (seat locking & overlay timing).
- Retained intact for diff-based archaeology. Use `integrated_hand_console_v2.html` for active work.
- If v2 regresses critically, revert by pointing tooling/tests back to this file.

Original Checklist (frozen):
- [ ] Launch prototype against current September2025 builds
- [ ] Run associated tests:
  - [ ] tests/unit/gameEventBridge.test.mjs
  - [ ] tests/unit/controllerRouterCore.test.mjs
  - [ ] tests/smoke/run_video_check_seats.mjs
- [ ] Capture findings + next steps in docs/TODO_2025-09-16.md
-->

<html>
<head>
  <meta charset="utf-8" />
  <title>Integrated Hand Console</title>
  <style>
    body { margin:0; font-family: system-ui, sans-serif; background:#0b0f14; color:#e5e7eb; display:grid; grid-template-columns: 2fr 1fr; height:100vh; }
    #left { position:relative; }
    video { width:100%; height:100%; object-fit:cover; background:#000; }
    canvas { position:absolute; inset:0; pointer-events:none; }
    #right { padding:12px; overflow:auto; display:flex; flex-direction:column; gap:14px; }
    h3 { margin:0 0 4px; font-size:14px; text-transform:uppercase; letter-spacing:0.5px; opacity:0.85; }
    .panel { background:#131a23; border:1px solid #1f2933; border-radius:10px; padding:10px 12px; }
    .row { display:flex; gap:8px; align-items:center; margin:2px 0; font-size:12px; }
    .mono { font-family: ui-monospace, Menlo, Consolas, monospace; }
    #log { font-size:11px; line-height:1.25; max-height:160px; overflow:auto; background:#0d141c; padding:6px; border-radius:6px; }
    .seat-badge { display:inline-block; padding:2px 6px; border-radius:4px; background:#374151; font-size:11px; }
    .seat-P1 { background:#2563eb; }
    .pinch-state { font-weight:bold; }
    .tube { position:relative; height:160px; width:54px; background:#0d141c; border:1px solid #1f2933; border-radius:8px; display:flex; flex-direction:column-reverse; margin-right:8px; }
    .tube-inner { position:absolute; inset:4px; display:flex; flex-direction:column-reverse; }
    .tube-fill { background:linear-gradient(180deg,#10b981,#2563eb); width:100%; border-radius:4px; }
    .tube-thresh { position:absolute; left:0; width:100%; height:2px; background:#fbbf24; opacity:0.9; }
    .tube-thresh.exit { background:#f87171; }
    .flexion-grid { display:grid; grid-template-columns: auto auto; font-size:12px; gap:4px 8px; }
    .vel { font-size:11px; opacity:0.8; }
  </style>
</head>
<body>
  <div id="left">
    <video id="cam" playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>
  <div id="right">
    <div class="panel">
      <h3>Capture</h3>
      <div class="row"><button id="startCam">Start Camera</button><button id="playVideo">Idle MP4</button></div>
      <div class="row">
        <select id="clipSel" style="font-size:12px;">
          <option value="../videos/two_hands_baseline_idle_v1.mp4">Idle (baseline)</option>
          <option value="../videos/two_hands_stationary_right_then_left_index_pinch_hold_1s_v1.mp4">P1 then P2 pinch/hold</option>
        </select>
        <button id="runClip">Run Clip</button>
      </div>
      <div class="row"><label><input type="checkbox" id="flagOrient" checked /> Wrist Orientation</label><label><input type="checkbox" id="flagFinger" checked /> Finger Flexion</label><label><input type="checkbox" id="palmGateToggle" checked /> Palm Gate</label></div>
    </div>

    <div class="panel" id="seatPanel">
      <h3>Seat Mapping</h3>
      <div id="seatInfo" class="mono">...</div>
    </div>

    <div class="panel" id="pinchPanel">
      <h3>P1 Hysteresis Tube</h3>
      <div style="display:flex; align-items:flex-end;">
        <div class="tube">
          <div class="tube-inner">
            <div class="tube-fill" id="tubeFill" style="height:0%"></div>
            <div class="tube-thresh" id="enterLine" title="Enter"></div>
            <div class="tube-thresh exit" id="exitLine" title="Exit"></div>
          </div>
        </div>
        <div style="flex:1; font-size:12px;">
          <div class="row">State: <span id="pinchState" class="pinch-state">Idle</span></div>
          <div class="row">Norm: <span id="pinchNorm">0.000</span></div>
          <div class="row">Velocity: <span id="pinchVel">0</span></div>
          <div class="row">Accel: <span id="pinchAcc">0</span></div>
          <div class="row">TOI (ms): <span id="pinchToi">∞</span></div>
        </div>
      </div>
    </div>

    <div class="panel" id="orientPanel">
      <h3>Wrist Orientation</h3>
      <div class="row">Raw/Smooth: <span id="orientAngles">-</span></div>
      <div class="row">Bucket: <span id="orientBucket">-</span></div>
      <div class="row vel">Velocity (deg/s): <span id="orientVel">0</span></div>
    </div>

    <div class="panel" id="flexPanel">
      <h3>Index Flexion (deg)</h3>
      <div class="flexion-grid">
        <div>MCP</div><div id="mcpDeg">-</div>
        <div>PIP</div><div id="pipDeg">-</div>
        <div>DIP</div><div id="dipDeg">-</div>
      </div>
    </div>

    <div class="panel">
      <h3>Recent Events</h3>
      <pre id="log"></pre>
    </div>
  </div>

  <script type="module">
    import { createAppShell } from '../src/app/appShell.js';
    // Feature flags (in-page overrides)
    globalThis.__flags = Object.assign({}, globalThis.__flags||{}, { FEATURE_WRIST_ORIENT_V1: true });

    const video = document.getElementById('cam');
    const overlay = document.getElementById('overlay');
    const octx = overlay.getContext('2d');

    // Create shell with orientation+finger geometry enabled
    const shell = createAppShell({});
    shell.hsm && shell.hsm.on(()=>{}); // ensure init

  const FLAG = { orient: true, finger: true };

    const logEl = document.getElementById('log');
    const MAX_LOG = 120; const evBuf=[];

  // Track latest events for the currently focused (P1) hand, but also keep a provisional cache
  // so orientation/flex/norm are visible BEFORE first pinch claims P1 (avoid gating observability).
  const latest = { pinch: null, orient: null, orientVel: null, flex: null, p1Key: null, lastP2: null, provisional: {} };

  // Track last seat occupants for highlighting transitions
  let lastSeatSnapshot = new Map();

    // Global event log for automated tests
    window.__ihcEvents = window.__ihcEvents || [];

    shell.onEvent(e => {
      // If P1 not yet claimed, stash orientation/flex/pinch per-hand so UI can show 'preview' of whichever hand will likely become P1.
      if(!latest.p1Key){
        if(!latest.provisional[e.handKey]) latest.provisional[e.handKey] = {};
        const slot = latest.provisional[e.handKey];
        if(e.type.startsWith('pinch:')) slot.pinch = e;
        if(e.type === 'wrist:orientation') slot.orient = e;
        if(e.type === 'wrist:orientationVel') slot.orientVel = e;
        if(e.type === 'finger:index:angles') slot.flex = e;
      }
      // Seat claim logic
      if(e.seat === 'P1' && !latest.p1Key && (e.type==='pinch:down' || e.type==='pinch:confirm' || e.type==='pinch:hold')){
        latest.p1Key = e.handKey;
        // Promote any provisional cache for chosen hand
        const chosen = latest.provisional[e.handKey];
        if(chosen){
          latest.pinch = chosen.pinch || latest.pinch;
          latest.orient = chosen.orient || latest.orient;
          latest.orientVel = chosen.orientVel || latest.orientVel;
          latest.flex = chosen.flex || latest.flex;
        }
      }
      if(latest.p1Key && e.handKey === latest.p1Key){
        if(e.type.startsWith('pinch:')) latest.pinch = e;
        if(e.type === 'wrist:orientation') latest.orient = e;
        if(e.type === 'wrist:orientationVel') latest.orientVel = e;
        if(e.type === 'finger:index:angles') latest.flex = e;
      }
      evBuf.push({ t:e.t, type:e.type, seat:e.seat||null, key:e.handKey });
      while(evBuf.length>MAX_LOG) evBuf.shift();
      if(e.type.startsWith('pinch:') || e.type.startsWith('wrist:orientation') || e.type.startsWith('finger:index:angles')){
        window.__ihcEvents.push({ t:e.t, type:e.type, seat:e.seat||null, key:e.handKey });
        if(window.__ihcEvents.length > 500) window.__ihcEvents.splice(0, window.__ihcEvents.length - 500);
      }
    });

    // Basic overlay draw: all landmarks + wrist->indexMCP vector(s)
    function drawOverlay(){
      const st = shell.getState();
      const frame = st.lastFrame;
      if(!frame){ octx.clearRect(0,0,overlay.width,overlay.height); return; }

      // High-DPI & resize handling (industry standard pattern)
      const dpr = window.devicePixelRatio || 1;
      const cw = overlay.clientWidth; const ch = overlay.clientHeight;
      if(overlay.width !== Math.round(cw*dpr) || overlay.height !== Math.round(ch*dpr)){
        overlay.width = Math.round(cw*dpr); overlay.height = Math.round(ch*dpr);
        octx.setTransform(1,0,0,1,0,0); octx.scale(dpr,dpr);
      }
      octx.clearRect(0,0,cw,ch);

      // Gather hands: prefer multi-hand snapshot if available
      const hands = (window.__hexLastHands && Array.isArray(window.__hexLastHands)) ? window.__hexLastHands : (frame.landmarks ? [frame.landmarks] : []);
      if(!hands.length) return;

      // Cover transform (maps source video frame to displayed area with object-fit:cover)
      const vw = video.videoWidth || cw; const vh = video.videoHeight || ch;
      const coverScale = Math.max(cw / vw, ch / vh);
      const drawW = vw * coverScale; const drawH = vh * coverScale;
      const dx = (cw - drawW) / 2; const dy = (ch - drawH) / 2; // negative if cropping (should be 0 or <=0 for cover)

      // MediaPipe standard connection pairs (HAND_CONNECTIONS equivalent)
      const CONN = [
        [0,1],[1,2],[2,3],[3,4],       // Thumb
        [0,5],[5,6],[6,7],[7,8],       // Index
        [5,9],[9,10],[10,11],[11,12],  // Middle
        [9,13],[13,14],[14,15],[15,16],// Ring
        [13,17],[0,17],[17,18],[18,19],[19,20],[20,0] // Pinky & wrap
      ];

      function getXY(lm){
        if(!lm) return null;
        if(Array.isArray(lm)) return { x: lm[0], y: lm[1], z: lm[2] ?? 0 };
        if(typeof lm.x === 'number' && typeof lm.y === 'number') return { x: lm.x, y: lm.y, z: lm.z || 0 };
        if('0' in lm && '1' in lm) return { x: lm[0], y: lm[1], z: lm[2]||0 };
        return null;
      }

      function normalizeHand(raw){
        // Build array of {x,y,z}
        const pts = raw.map(getXY).filter(Boolean);
        if(!pts.length) return [];
        let maxX=-Infinity,maxY=-Infinity,minX=Infinity,minY=Infinity; pts.forEach(p=>{ if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; });
        const normalized = (maxX<=1 && maxY<=1 && minX>=0 && minY>=0);
        // Map to screen
        return pts.map(p=>{
          let sx, sy;
          if(normalized){
            sx = dx + p.x * drawW; sy = dy + p.y * drawH;
          } else {
            // Pixel space relative to source video dims
            sx = dx + (p.x / vw) * drawW;
            sy = dy + (p.y / vh) * drawH;
          }
          return { sx, sy, z: p.z };
        });
      }

      // Depth range estimation (z often negative forward). We'll collect all z for dynamic sizing.
      const screenHands = hands.map(normalizeHand);
      const allZ = screenHands.flat().map(p=>p.z).filter(z=>isFinite(z));
      const zMin = allZ.length ? Math.min(...allZ) : -0.1;
      const zMax = allZ.length ? Math.max(...allZ) : 0.1;
      const zRange = (zMax - zMin) || 1;

      screenHands.forEach((pts, hi)=>{
        if(!pts.length) return;
        // Draw skeleton connections
        octx.lineCap = 'round';
        octx.lineJoin = 'round';
        CONN.forEach(([a,b])=>{
          const pa = pts[a]; const pb = pts[b];
          if(!pa || !pb) return;
          octx.strokeStyle = hi===0 ? 'rgba(16,185,129,0.85)' : 'rgba(245,158,11,0.85)';
          octx.lineWidth = 3;
          octx.beginPath(); octx.moveTo(pa.sx, pa.sy); octx.lineTo(pb.sx, pb.sy); octx.stroke();
        });
        // Joints with depth-based size & subtle shadow
        pts.forEach((p, idx)=>{
          const dz = (p.z - zMin)/zRange; // 0..1
          const r = 2.2 + (1-dz)*3.5; // nearer = larger
          octx.beginPath();
          if(hi===0){
            octx.fillStyle = idx<=4 ? '#0ea5e9' : '#10b981'; // thumb vs others
          } else {
            octx.fillStyle = idx<=4 ? '#f59e0b' : '#fbbf24';
          }
          octx.arc(p.sx, p.sy, r, 0, Math.PI*2);
          octx.fill();
        });
      });

      // Optional debug rect – uncomment if alignment still off
      // octx.strokeStyle = 'rgba(255,255,255,0.15)'; octx.strokeRect(dx,dy,drawW,drawH);
    }

    function fmt(n, d=1){ return (n==null||!isFinite(n))?'-':n.toFixed(d); }

    function render(){
      // Seat mapping & highlight transitions
      const st = shell.getState();
      const seatMap = new Map(st.seats.map);
      let p1Info = 'P1: (unassigned)';
      if(seatMap.has('P1')){ p1Info = 'P1: '+seatMap.get('P1'); }
      document.getElementById('seatInfo').textContent = p1Info;
      // Detect seat changes
      seatMap.forEach((seat, handKey)=>{});
      for(const [seat, handKey] of seatMap.entries()){
        const prev = lastSeatSnapshot.get(seat);
        if(prev !== handKey){
          // Push synthetic log line to highlight seat change
          evBuf.push({ t: performance.now().toFixed(0), type:`seat:${seat}:assign`, seat, key: handKey });
          while(evBuf.length>MAX_LOG) evBuf.shift();
        }
      }
      lastSeatSnapshot = new Map(seatMap.entries());

      // Pinch hysteresis tube (use latest pinch state if known)
      // Prefer live P1 pinch; if not yet claimed, pick first provisional entry for preview
      let pinch = latest.pinch;
      if(!pinch && !latest.p1Key){
        const keys = Object.keys(latest.provisional);
        if(keys.length){ pinch = latest.provisional[keys[0]].pinch || null; }
      }
      const fill = document.getElementById('tubeFill');
      const enterLine = document.getElementById('enterLine');
      const exitLine = document.getElementById('exitLine');
      if(pinch && pinch.thresholds){
        const norm = pinch.normalizedGap ?? pinch.norm ?? 0;
        const enterT = pinch.thresholds.enter;
        const exitT = pinch.thresholds.exit;
        fill.style.height = Math.min(100, Math.max(0, (1-norm)*100))+'%';
        enterLine.style.bottom = ((1-enterT)*100)+'%';
        exitLine.style.bottom = ((1-exitT)*100)+'%';
        document.getElementById('pinchState').textContent = pinch.type.startsWith('pinch:up')? 'Idle' : (pinch.type==='pinch:down'||pinch.type==='pinch:confirm'?'Down':'Pinched');
        document.getElementById('pinchNorm').textContent = fmt(norm,3);
        document.getElementById('pinchVel').textContent = fmt(pinch.pinchVelocity,1);
        document.getElementById('pinchAcc').textContent = fmt(pinch.pinchAcceleration,1);
        document.getElementById('pinchToi').textContent = fmt(pinch.msToTouchVel,0);
      }

      // Orientation
      const orient = latest.orient;
      if(orient){
        document.getElementById('orientAngles').textContent = `${fmt(orient.angleDeg,1)}° / ${fmt(orient.smoothAngleDeg,1)}°`;
        document.getElementById('orientBucket').textContent = orient.bucket;
      }
      const ov = latest.orientVel; if(ov){ document.getElementById('orientVel').textContent = fmt(ov.velDegPerSec,0); }

      // Flexion
      const flex = latest.flex; if(flex){
        document.getElementById('mcpDeg').textContent = fmt(flex.mcpDeg,0);
        document.getElementById('pipDeg').textContent = fmt(flex.pipDeg,0);
        document.getElementById('dipDeg').textContent = fmt(flex.dipDeg,0);
      }

      // Log
      logEl.textContent = evBuf.slice(-60).map(e=> {
        if(e.type.startsWith('seat:')) return `[SEAT] ${e.type} -> ${e.key}`;
        if(e.type.startsWith('pinch:down')) return `[DOWN ] t=${e.t} ${e.seat||''} ${e.key||''}`;
        if(e.type.startsWith('pinch:up')) return `[UP   ] t=${e.t} ${e.seat||''} ${e.key||''}`;
        if(e.type==='pinch:hold') return `[HOLD ] t=${e.t} ${e.seat||''} ${e.key||''}`;
        return `${e.t} ${e.type} ${e.seat||''} ${e.key||''}`;
      }).join('\n');

      drawOverlay();
    }

    setInterval(render, 200);

    async function startCam(){ await shell.startCamera(video); }
    async function playVideo(){ const url = '../videos/two_hands_baseline_idle_v1.mp4'; await shell.startVideoUrl(video, url); }
  async function runSelected(){
    let url = document.getElementById('clipSel').value;
    try { await shell.startVideoUrl(video, url); }
    catch(e){
      // Retry with leading slash if not already absolute (some tests expect absolute path served by http-server root)
      if(!url.startsWith('/')){
        const abs = '/' + url.replace(/^\.\/?/, '');
        try { await shell.startVideoUrl(video, abs); } catch { console.warn('Fallback video load failed', abs); }
      } else { console.warn('Video load failed', url, e); }
    }
  }
    document.getElementById('startCam').onclick = startCam;
    document.getElementById('playVideo').onclick = playVideo;
    document.getElementById('runClip').onclick = runSelected;

    // Query param support: ?clip= & ?autostart=1
    (function(){
      const Q = new URLSearchParams(location.search);
      const qpClip = Q.get('clip');
      const autostart = Q.get('autostart') === '1' || Q.get('auto') === '1';
      if(qpClip){
        // Normalize query clip path. Cases:
        // 1) Already absolute (starts with '/') -> keep
        // 2) Starts with repository segment 'September2025/' -> make absolute '/September2025/...'
        // 3) Bare filename or videos/* -> prefix '../videos/' (relative from /dev/)
        let clipPath = qpClip.trim();
        if(!clipPath.startsWith('/')){
          if(clipPath.startsWith('September2025/')){
            clipPath = '/' + clipPath; // absolute to avoid duplicated segments like dev/September2025/...
          } else if(!clipPath.startsWith('..')) {
            if(!clipPath.startsWith('videos/')){ clipPath = 'videos/' + clipPath; }
            clipPath = '../' + clipPath; // from dev/ up one to TectangleHexagonal/
          }
        }
        // Attempt to select matching option
        const sel = document.getElementById('clipSel');
        let matched = false;
        for(const opt of sel.options){ if(opt.value === clipPath){ sel.value = clipPath; matched = true; break; } }
        if(!matched){
          // Inject a dynamic option
            const o = document.createElement('option'); o.value = clipPath; o.textContent = 'Query Clip'; sel.appendChild(o); sel.value = clipPath;
        }
        if(autostart){
          setTimeout(()=>{ runSelected(); }, 150);
        }
      } else if(autostart){
        setTimeout(()=>{ runSelected(); }, 150);
      }
    })();

    // Palm gate toggle (runtime): update pinch cores via AppShell's hsm pinch core setConfig
    document.getElementById('palmGateToggle').addEventListener('change', (e)=>{
      const enabled = e.target.checked;
      try{
        // Runtime apply to existing pinch cores if handSessionManager implemented updatePinchConfig
        if(shell.hsm && typeof shell.hsm.updatePinchConfig === 'function'){
          shell.hsm.updatePinchConfig({ palmGate: enabled });
        } else {
          // Fallback: set global flag (picked up on next reload/start)
          globalThis.__flags = Object.assign({}, globalThis.__flags, { PALM_GATE_FORCE: enabled });
        }
      }catch(err){ console.warn('Palm gate toggle failed', err); }
    });

  </script>
</body>
</html>
