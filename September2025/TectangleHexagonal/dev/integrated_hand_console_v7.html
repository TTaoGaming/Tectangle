<!doctype html>
<!--
Hand Console V7 (Unified Overlay + Panels)
Status: EXPERIMENTAL (scaffold)
Feature Flag: FEATURE_HAND_CONSOLE_V7
Depends On: FEATURE_HAND_CONSOLE_VM (always enabled internally)
TTL: 2025-10-10 (remove or graduate)
Goal: Merge V6 fast overlay rendering with V4 structured signal panels via unified ViewModel.
Revert: delete this file + flag; previous versions (V4/V6) remain.
WEBWAY:ww-2025-008 marker present for aggregation path reuse.
-->
<html>
<head>
  <meta charset="utf-8" />
  <title>Hand Console V7</title>
  <link rel="stylesheet" href="./hexui.css" />
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font:12px system-ui,sans-serif; background:#0b1117; color:#e5e7eb; display:grid; grid-template-columns: 2fr 1fr; height:100vh; }
    #left { position:relative; }
    video { width:100%; height:100%; object-fit:cover; background:#000; }
    canvas { position:absolute; inset:0; pointer-events:none; }
    #boot { position:absolute; top:10px; left:10px; background:rgba(0,0,0,.55); padding:6px 8px; border-radius:8px; font-size:12px; line-height:1.3; }
    #right { display:flex; flex-direction:column; gap:12px; padding:12px; overflow:auto; }
    h3 { margin:0 0 6px; font-size:12px; opacity:.8; letter-spacing:.5px; text-transform:uppercase; }
    .panel { background:#131a23; border:1px solid #1e2833; border-radius:10px; padding:10px 12px; }
    .mono { font-family:ui-monospace,Menlo,Consolas,monospace; }
    button { font:inherit; padding:4px 10px; border-radius:6px; background:#0d141c; color:#e5e7eb; border:1px solid #1e2833; cursor:pointer; }
    #log { font-size:11px; max-height:140px; overflow:auto; background:#0d141c; padding:6px; border-radius:8px; }
    .grid { display:grid; grid-template-columns:auto 1fr; gap:2px 10px; }
    .badge { padding:2px 6px; border-radius:4px; background:#374151; font-size:11px; }
    .badge.P1 { background:#2563eb; }
    .badge.P2 { background:#8b5cf6; }
  </style>
</head>
<body>
  <div id="left">
    <video id="cam" playsinline muted></video>
    <canvas id="ov"></canvas>
    <div id="boot">Booting V7…<br><span style="opacity:.7">unified overlay</span></div>
  </div>
  <div id="right">
    <div class="panel">
      <h3>Capture</h3>
      <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
        <button id="startCam">Camera</button>
        <button id="runClip">Clip</button>
        <select id="clipSel" style="font:inherit;font-size:12px;">
          <option value="../videos/two_hands_baseline_idle_v1.mp4">Idle</option>
          <option value="../videos/two_hands_stationary_right_then_left_index_pinch_hold_1s_v1.mp4">Pinch Seq</option>
        </select>
        <label style="font-size:11px;display:flex;align-items:center;gap:4px;">
          <input id="mirrorToggle" type="checkbox" /> mirror
        </label>
        <span id="capStatus" class="mono" style="font-size:11px;opacity:.7;">idle</span>
      </div>
      <div id="camConstraints" style="margin-top:8px;display:none;gap:6px;flex-wrap:wrap;align-items:center;font-size:11px;">
        <!-- WEBWAY:ww-2025-011 responsive camera controls -->
        <select id="resPreset" style="font:inherit;font-size:11px;">
          <option value="640x480">640x480</option>
          <option value="960x540">960x540</option>
          <option value="1280x720">1280x720</option>
          <option value="1920x1080">1920x1080</option>
        </select>
        <select id="fpsPreset" style="font:inherit;font-size:11px;">
          <option value="30">30fps</option>
          <option value="60">60fps</option>
        </select>
        <button id="applyConstraintsBtn">Apply</button>
        <span id="constraintsStatus" class="mono" style="opacity:.65;">-</span>
      </div>
    </div>
    <div class="panel">
      <h3>Seats</h3>
      <div id="seatSummary" class="mono" style="font-size:12px;">P1=- | P2=-</div>
    </div>
    <div class="panel">
      <h3>Signals</h3>
      <div id="signalsGrid" class="grid mono" style="font-size:11px;"></div>
    </div>
    <div class="panel">
      <h3>Recent Pinch</h3>
      <pre id="log" class="mono">(none)</pre>
    </div>
    <div class="panel">
      <h3>Diag</h3>
      <div id="diag" class="mono" style="font-size:11px;">frames=0 ops=0 hands=0 vm=on</div>
    </div>
  </div>

  <script type="module">
  // WEBWAY:ww-2025-020 path depth correction (dev -> TectangleHexagonal -> September2025 -> project root)
  // Corrected depth: dev/ and src/ are siblings so use ../src/* (WEBWAY:ww-2025-020 depth fix 2)
  import { createAppShell } from '../src/app/appShell.js';
  import { createOverlayOpsPort } from '../src/ports/overlayOpsPort.js';
  import { createCanvasOverlayRenderer } from '../src/ui/canvasOverlayRenderer.js';
  import { createHandConsoleViewModel } from '../src/ui/createHandConsoleViewModel.js'; // WEBWAY:ww-2025-008 + ww-2025-020
  globalThis.__flags = Object.assign({}, globalThis.__flags||{}, { FEATURE_HAND_CONSOLE_V7:true, FEATURE_HAND_CONSOLE_VM:true, FEATURE_OVERLAY_REDO:true, FEATURE_OVERLAY_DEBUG:true, FEATURE_CAMERA_CONSTRAINTS:true }); // WEBWAY:ww-2025-010 overlay redo + debug + WEBWAY:ww-2025-011 responsive

    const video = document.getElementById('cam');
    const canvas = document.getElementById('ov');
    const ctx = canvas.getContext('2d');

    const shell = createAppShell({ seats:['P1','P2'] });
    const vmCore = createHandConsoleViewModel(); // always on for V7

    function getFrame(){ try { return shell.getState && shell.getState().lastFrame || null; } catch { return null; } }
    function getSeats(){ try { return (shell.getState && shell.getState().seats && shell.getState().seats.seats)||{}; } catch { return {}; } }

  const opsPort = createOverlayOpsPort({ getFrame, getSeats, getVideoDims: ()=>({ width: video.videoWidth||0, height: video.videoHeight||0 }), spanWarn: !!globalThis.__flags?.FEATURE_CAMERA_CONSTRAINTS }); // WEBWAY:ww-2025-010 inject dims + WEBWAY:ww-2025-011 spanWarn
  const renderer = createCanvasOverlayRenderer({ canvas, video, fit:'cover', mirror:false });

    const diag = { frames:0, errors:[], ops:0, lastHandCount:0, pinchLog:[] };
    globalThis.__ihcV7 = { shell, vmCore, diag }; // debug hook

    shell.onEvent(ev => { vmCore.onEvent(ev); if(ev.type && ev.type.startsWith('pinch:')) { diag.pinchLog.push(`${ev.t} ${ev.type} ${ev.seat||''}`); if(diag.pinchLog.length>140) diag.pinchLog.splice(0,80); } });

    function resize(){
      const container = video.parentElement;
      const cw = container.clientWidth || window.innerWidth;
      const ch = container.clientHeight || window.innerHeight;
      if(canvas.width!==cw || canvas.height!==ch){ canvas.width=cw; canvas.height=ch; }
    }
    window.addEventListener('resize', resize);

    function fillSignals(){
      const snap = vmCore.snapshot();
      const grid = document.getElementById('signalsGrid');
      grid.innerHTML='';
      const hands = Object.keys(snap.hands);
      diag.lastHandCount = hands.length;
      if(!hands.length){ grid.innerHTML='<span style="opacity:.6">No hands yet</span>'; return; }
      function fmt(n,d=1){ return (n==null||!isFinite(n))?'-':(+n).toFixed(d); }
      for(const hk of hands){
        const h = snap.hands[hk];
        const pairs = [ ['Hand', hk] ];
        if(h.pinch){ pairs.push(['Pinch', h.pinch.type.replace('pinch:','')]); pairs.push(['Gap', fmt(h.pinch.normalizedGap??h.pinch.norm,3)]); }
        if(h.orient){ pairs.push(['Orient', fmt(h.orient.angleDeg,1)+'°']); pairs.push(['Bucket', h.orient.bucket]); }
        if(h.vel){ pairs.push(['Vel', fmt(h.vel.velDegPerSec,0)+'°/s']); }
        if(h.flex){ pairs.push(['Index MCP/PIP/DIP', `${fmt(h.flex.mcpDeg,0)}/${fmt(h.flex.pipDeg,0)}/${fmt(h.flex.dipDeg,0)}`]); }
        for(const [k,v] of pairs){ const kd=document.createElement('div'); kd.textContent=k; const vd=document.createElement('div'); vd.textContent=v; grid.appendChild(kd); grid.appendChild(vd); }
      }
    }

    function render(){
      try {
        resize();
        const sample = opsPort.sample();
        diag.ops = sample.ops.length;
        const mirrorToggle = document.getElementById('mirrorToggle');
        if(mirrorToggle) renderer.mirror = !!mirrorToggle.checked;
        renderer.render(sample);
      } catch(err){ if(diag.errors.length<8) console.warn('[v7] overlay error', err); diag.errors.push(String(err?.message||err)); }
      try {
        const snap = vmCore.snapshot();
        const seats = snap.seats || {};
        document.getElementById('seatSummary').textContent = `P1=${seats.P1||'-'} | P2=${seats.P2||'-'}`;
        fillSignals();
      } catch(err){ diag.errors.push('state:'+ (err?.message||err)); }
      document.getElementById('log').textContent = diag.pinchLog.slice(-80).join('\n') || '(none)';
      document.getElementById('diag').textContent = `frames=${diag.frames} errors=${diag.errors.length} ops=${diag.ops} hands=${diag.lastHandCount} vm=on`;
      const boot = document.getElementById('boot'); if(boot){ if(diag.frames>30 || video.readyState>=2) boot.style.display='none'; }
    }

    function loop(){ diag.frames++; vmCore.tick(); render(); requestAnimationFrame(loop); }
    loop();

  async function startCamera(){ const st=document.getElementById('capStatus'); st.textContent='camera...'; try{ await shell.startCamera(video); st.textContent='camera'; enableConstraintUIIfFlag(); } catch(e){ st.textContent='cam fail'; diag.errors.push('cam:'+e.message); } }
    async function startClip(url){ const st=document.getElementById('capStatus'); st.textContent='clip...'; try{ await shell.startVideoUrl(video,url); st.textContent='clip'; } catch(e){ st.textContent='clip fail'; diag.errors.push('clip:'+e.message); } }
    function runClipSel(){ const sel=document.getElementById('clipSel'); if(!sel) return; startClip(sel.value); }
  document.getElementById('startCam').onclick=()=>startCamera();
    document.getElementById('runClip').onclick=()=>runClipSel();

    function enableConstraintUIIfFlag(){
      if(!globalThis.__flags?.FEATURE_CAMERA_CONSTRAINTS) return;
      const wrap = document.getElementById('camConstraints'); if(!wrap) return;
      wrap.style.display='flex';
    }
    function parseRes(v){ if(!v) return {}; const [w,h]=v.split('x').map(x=>parseInt(x,10)); return { width:w, height:h }; }
    function applyCameraConstraints(){
      const res = parseRes(document.getElementById('resPreset').value);
      const fps = parseInt(document.getElementById('fpsPreset').value,10);
      const st = document.getElementById('constraintsStatus'); st.textContent='…';
      shell.applyCameraConstraints(video, { ...res, frameRate: fps }).then(r=>{
        if(!r.applied){ st.textContent='retry'; if(r.reason==='no-stream'){ st.textContent='no-stream'; }
        } else { st.textContent = `${r.settings.width||res.width||'?'}x${r.settings.height||res.height||'?'}@${r.settings.frameRate||fps||'?'} ok`; }
      });
    }
    document.getElementById('applyConstraintsBtn')?.addEventListener('click', applyCameraConstraints);
    document.addEventListener('camera:constraints-applied', e=>{
      const st=document.getElementById('constraintsStatus'); if(!st) return; const d=e.detail||{}; st.textContent = `${d.settings?.width||'?'}x${d.settings?.height||'?'} @${d.settings?.frameRate||'?'} (${d.method})`;
    });
    document.addEventListener('camera:constraints-failed', e=>{ const st=document.getElementById('constraintsStatus'); if(st) st.textContent='fail'; });

    (function initQP(){ const Q=new URLSearchParams(location.search); const qpClip=Q.get('clip'); const auto=Q.get('autostart')==='1'||Q.get('auto')==='1'; const nocam=Q.get('nocam')==='1'; function normalizeClip(p){ if(!p) return p; let c=p.trim(); if(!c.startsWith('/')){ if(c.startsWith('September2025/')) c='/'+c; else if(!c.startsWith('..')){ if(!c.startsWith('videos/')) c='videos/'+c; c='../'+c; } } return c; } if(qpClip){ const clip=normalizeClip(qpClip); const sel=document.getElementById('clipSel'); let matched=false; for(const o of sel.options){ if(o.value===clip){ matched=true; sel.value=clip; break; } } if(!matched){ const o=document.createElement('option'); o.value=clip; o.textContent='Query Clip'; sel.appendChild(o); sel.value=clip; } if(auto) setTimeout(()=>startClip(clip),160); else if(!nocam) setTimeout(()=>startCamera(),240); } else if(auto){ if(!nocam) setTimeout(()=>startCamera(),160); else setTimeout(()=>runClipSel(),200); } else { /* no auto */ } })();
  </script>
</body>
</html>
