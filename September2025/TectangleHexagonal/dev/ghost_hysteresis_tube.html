<!doctype html>
<!--
STIGMERGY REVIEW HEADER
Status: Pending verification
Review started: 2025-09-16T19:32-06:00
Expires: 2025-09-23T19:32-06:00 (auto-expire after 7 days)

Checklist:
- [ ] Launch prototype against current September2025 builds
- [ ] Run associated tests:
  - [ ] tests/unit/pinchCore.test.mjs
  - [ ] tests/unit/lookAheadCore.test.mjs
  - [ ] tests/e2e/pinch_to_vendor_bridge.test.mjs
- [ ] Capture findings + next steps in docs/TODO_2025-09-16.md
-->

<html>
<head>
  <meta charset="utf-8" />
  <title>Hex — Ghost Hysteresis Tube (WEBWAY:ww-2025-003)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; margin: 0; display: grid; grid-template-columns: 360px 1fr; height: 100vh; }
    #panel { padding: 12px; border-right: 1px solid #222; background:#0b0b0b; color:#e8e8e8 }
    #panel h2 { margin: 8px 0 6px; font-size: 16px; }
    #panel label { display:block; margin: 8px 0 2px; font-size: 12px; color:#bbb }
    #panel input[type=range] { width:100% }
    #panel .small { font-size:11px; color:#aaa }
    #stage { position: relative; background:#111; display:flex; align-items:center; justify-content:center; }
    canvas { background:#111; }
    .pill { display:inline-block; padding:2px 6px; border-radius:10px; margin-right:6px; font-size:11px }
    .pill.ok { background:#1b5e20; color:#d8ffd8 }
    .pill.bad { background:#5e1b1b; color:#ffd8d8 }
  </style>
</head>
<body>
  <div id="panel">
    <h2>Ghost Hysteresis Tube</h2>
    <div>
      <span class="pill" id="palmStatus">Palm: ?</span>
      <span class="pill" id="ghostStatus">Ghost: off</span>
    </div>

    <label>Enter threshold (norm)</label>
    <input id="enter" type="range" min="0" max="1" step="0.01" value="0.40">
    <div class="small" id="enterVal">0.40</div>

    <label>Exit threshold (norm)</label>
    <input id="exit" type="range" min="0" max="1" step="0.01" value="0.60">
    <div class="small" id="exitVal">0.60</div>

    <label>Lookahead Ms (lead)</label>
    <input id="leadMs" type="range" min="0" max="120" step="5" value="35">
    <div class="small" id="leadMsVal">35 ms</div>

    <details>
      <summary>Advanced</summary>
      <label>Confirm Down Ms</label>
      <input id="confirmDownMs" type="range" min="0" max="160" step="10" value="40">
      <div class="small" id="confirmDownMsVal">40 ms</div>

      <label>Confirm Up Ms</label>
      <input id="confirmUpMs" type="range" min="0" max="200" step="10" value="90">
      <div class="small" id="confirmUpMsVal">90 ms</div>

      <label>Min Hold Ms</label>
      <input id="minHoldMs" type="range" min="0" max="240" step="10" value="120">
      <div class="small" id="minHoldMsVal">120 ms</div>

      <label>Refractory Ms</label>
      <input id="refractoryMs" type="range" min="0" max="200" step="10" value="60">
      <div class="small" id="refractoryMsVal">60 ms</div>

      <label>Palm cone (deg)</label>
      <input id="coneDeg" type="range" min="10" max="80" step="1" value="30">
      <div class="small" id="coneDegVal">30°</div>

      <label>EMA α for TOI</label>
      <input id="toiAlpha" type="range" min="0" max="1" step="0.05" value="0.4">
      <div class="small" id="toiAlphaVal">0.40</div>

      <label>Clamp dTOI (ms/frame)</label>
      <input id="toiClamp" type="range" min="5" max="50" step="5" value="20">
      <div class="small" id="toiClampVal">20</div>
    </details>

    <p class="small">WEBWAY:ww-2025-003: This sidecar observes `window.__hexLastHands` and draws a tube. Revert by deleting this file.</p>

    <button id="startIframe">Start Camera (iframe)</button>
  </div>
  <div id="stage">
    <canvas id="tube" width="600" height="600"></canvas>
    <iframe id="app" src="./index.html?noauto=1" style="position:absolute; right:8px; bottom:8px; width:360px; height:240px; border:1px solid #333;"></iframe>
  </div>

  <script>
  // WEBWAY:ww-2025-003: sidecar script
  const qs = (id)=>document.getElementById(id);
  const tube = qs('tube');
  const ctx = tube.getContext('2d');
  const app = qs('app');

  const knobs = {
    enter: qs('enter'), exit: qs('exit'),
    leadMs: qs('leadMs'), confirmDownMs: qs('confirmDownMs'), confirmUpMs: qs('confirmUpMs'),
    minHoldMs: qs('minHoldMs'), refractoryMs: qs('refractoryMs'), coneDeg: qs('coneDeg'),
    toiAlpha: qs('toiAlpha'), toiClamp: qs('toiClamp'),
  };
  const labels = {
    enterVal: qs('enterVal'), exitVal: qs('exitVal'), leadMsVal: qs('leadMsVal'),
    confirmDownMsVal: qs('confirmDownMsVal'), confirmUpMsVal: qs('confirmUpMsVal'),
    minHoldMsVal: qs('minHoldMsVal'), refractoryMsVal: qs('refractoryMsVal'),
    coneDegVal: qs('coneDegVal'), toiAlphaVal: qs('toiAlphaVal'), toiClampVal: qs('toiClampVal'),
  };
  function syncLabels(){
    labels.enterVal.textContent = (+knobs.enter.value).toFixed(2);
    labels.exitVal.textContent = (+knobs.exit.value).toFixed(2);
    labels.leadMsVal.textContent = knobs.leadMs.value + ' ms';
    labels.confirmDownMsVal.textContent = knobs.confirmDownMs.value + ' ms';
    labels.confirmUpMsVal.textContent = knobs.confirmUpMs.value + ' ms';
    labels.minHoldMsVal.textContent = knobs.minHoldMs.value + ' ms';
    labels.refractoryMsVal.textContent = knobs.refractoryMs.value + ' ms';
    labels.coneDegVal.textContent = knobs.coneDeg.value + '°';
    labels.toiAlphaVal.textContent = (+knobs.toiAlpha.value).toFixed(2);
    labels.toiClampVal.textContent = knobs.toiClamp.value;
  }
  Object.values(knobs).forEach(el=>el.addEventListener('input', syncLabels));
  syncLabels();

  const state = {
    ghost:false,
    lastToggleT:0,
    lastDownT:0,
    gateOK:false,
    gateStreakMs:0,
    prevNorm:null,
    prevT:null,
    toiEma:null,
    downCondStreakMs:0,
    upCondStreakMs:0,
  };

  function palmConeOK(hand, coneDeg){
    // Uses wrist, indexMCP, pinkyMCP to derive palm normal; camera forward ~ +Z
    if(!hand?.wrist || !hand?.indexMCP || !hand?.pinkyMCP) return false;
    const w = hand.wrist, i = hand.indexMCP, p = hand.pinkyMCP;
    const cx = (i.x + p.x)/2, cy = (i.y + p.y)/2, cz = (i.z + p.z)/2;
    const vx = cx - w.x, vy = cy - w.y, vz = cz - w.z; // wrist -> palm center
    // Approx camera forward: negative Z in MediaPipe; use dot with (0,0,-1)
    const dot = (vx*0 + vy*0 + vz*(-1));
    const vlen = Math.hypot(vx,vy,vz);
    if(vlen < 1e-6) return false;
    const cos = dot / vlen;
    const angle = Math.acos(Math.max(-1, Math.min(1, cos))) * 180/Math.PI;
    return angle <= coneDeg;
  }

  function normFrom(hand){
    // normalized indexTip↔thumbTip by palm width (indexMCP↔pinkyMCP)
    if(!hand?.indexTip || !hand?.thumbTip || !hand?.indexMCP || !hand?.pinkyMCP) return null;
    const d = (a,b)=>Math.hypot(a.x-b.x, a.y-b.y);
    const palm = d(hand.indexMCP, hand.pinkyMCP) || 1e-6;
    return d(hand.indexTip, hand.thumbTip) / palm;
  }

  function estTOI_ms(norm, vRel, enter){
    // Predict time until norm reaches enter threshold assuming constant velocity toward
    if(!(vRel<0)) return Infinity; // only meaningful when closing
    const dist = norm - enter;
    if(dist <= 0) return 0;
    // vRel is per ms (we compute below); avoid div by tiny
    const eps = 1e-6;
    return Math.max(0, dist / Math.max(eps, -vRel));
  }

  function clampDelta(prev, next, clamp){
    if(prev==null) return next;
    const delta = next - prev;
    const d = Math.max(-clamp, Math.min(clamp, delta));
    return prev + d;
  }

  function updateGhostLogic(nowT, norm, vRel, gateOK){
    const lead = +knobs.leadMs.value;
    const cDown = +knobs.confirmDownMs.value;
    const cUp = +knobs.confirmUpMs.value;
    const minHold = +knobs.minHoldMs.value;
    const refrac = +knobs.refractoryMs.value;

    // TOI estimate with EMA and clamp
  const toi = estTOI_ms(norm, vRel, +knobs.enter.value);
  const alpha = +knobs.toiAlpha.value;
  if(state.toiEma==null) state.toiEma = toi;
  const prevEma = state.toiEma;
  const nextEma = alpha*toi + (1-alpha)*prevEma;
  state.toiEma = clampDelta(prevEma, nextEma, +knobs.toiClamp.value);

    // Gate streak
    state.gateOK = !!gateOK;
    if(state.gateOK) state.gateStreakMs += (state.prevT? nowT - state.prevT : 0); else state.gateStreakMs = 0;

    const inRefrac = (nowT - state.lastToggleT) < refrac;

    if(!state.ghost){
      const downCond = state.gateOK && state.gateStreakMs >= 60 && vRel < 0 && state.toiEma <= lead;
      state.downCondStreakMs = downCond ? (state.downCondStreakMs + (state.prevT? nowT - state.prevT : 0)) : 0;
      if(state.downCondStreakMs >= cDown && !inRefrac){
        state.ghost = true; state.lastToggleT = nowT; state.lastDownT = nowT; state.upCondStreakMs = 0;
      }
    } else {
      const heldLongEnough = (nowT - state.lastDownT) >= minHold;
      const upBase = (vRel > 0) || (heldLongEnough && !(state.gateOK && vRel<0 && state.toiEma <= lead));
      state.upCondStreakMs = upBase ? (state.upCondStreakMs + (state.prevT? nowT - state.prevT : 0)) : 0;
      const upReady = state.upCondStreakMs >= cUp;
      if(upReady && !inRefrac){ state.ghost = false; state.lastToggleT = nowT; state.downCondStreakMs = 0; }
    }

    return { ghost: state.ghost, toi: state.toiEma };
  }

  function drawTube(norm, enter, exit, gateOK, ghost){
    const w = tube.width, h = tube.height; const cx = w/2, cy = h/2; const R = Math.min(w,h)/2 - 20;
    ctx.clearRect(0,0,w,h);

    // Tube background
    ctx.save();
    ctx.translate(cx, cy);

    // Outer circle
    ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2); ctx.strokeStyle = '#333'; ctx.lineWidth = 4; ctx.stroke();

    // Hysteresis ring: map norm [0..1] to radius [R*0.3..R*0.95]
    const rEnter = R * (0.3 + 0.65*enter);
    const rExit  = R * (0.3 + 0.65*exit);
    ctx.beginPath(); ctx.arc(0,0,rEnter,0,Math.PI*2); ctx.strokeStyle = '#4caf50'; ctx.setLineDash([6,4]); ctx.lineWidth=2; ctx.stroke();
    ctx.beginPath(); ctx.arc(0,0,rExit,0,Math.PI*2); ctx.strokeStyle = '#f44336'; ctx.setLineDash([2,4]); ctx.lineWidth=2; ctx.stroke();
    ctx.setLineDash([]);

    // Dot position along a vertical axis mapped by norm
    const rNorm = R * (0.3 + 0.65*Math.max(0, Math.min(1, norm ?? 0)));
    ctx.beginPath(); ctx.arc(0,-rNorm,8,0,Math.PI*2);
    ctx.fillStyle = gateOK ? '#12d400' : '#7a7a7a';
    ctx.fill();

    // Ghost band: white ring on the outer edge when ghost is active
    if(ghost){
      ctx.beginPath(); ctx.arc(0,0,R-2,0,Math.PI*2);
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 6; ctx.globalAlpha = 0.9; ctx.stroke(); ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  function getRightHandFromIframe(){
    try{
      const w = app.contentWindow;
      const hands = w?.__hexLastHands; // { right: {...}, left: {...} }
      return hands?.right || hands?.[0] || null;
    }catch(e){ return null; }
  }

  function tick(){
    const now = performance.now();
    const hand = getRightHandFromIframe();
    const palmOK = hand ? palmConeOK(hand, +knobs.coneDeg.value) : false;
    const norm = hand ? normFrom(hand) : null;

    // velocity from smoothed/observable norm; simple diff
    let vRel = 0;
    if(norm!=null && state.prevNorm!=null && state.prevT!=null){
      const dt = Math.max(1, now - state.prevT);
      vRel = (norm - state.prevNorm) / dt; // per ms
    }

    const { ghost } = updateGhostLogic(now, norm ?? 1.0, vRel, palmOK);

    // badges
    const palmStatus = document.getElementById('palmStatus');
    palmStatus.textContent = palmOK ? 'Palm: OK' : 'Palm: out';
    palmStatus.className = 'pill ' + (palmOK ? 'ok' : 'bad');
    const ghostStatus = document.getElementById('ghostStatus');
    ghostStatus.textContent = 'Ghost: ' + (ghost ? 'on' : 'off');
    ghostStatus.className = 'pill ' + (ghost ? 'ok' : 'bad');

    drawTube(norm ?? 1.0, +knobs.enter.value, +knobs.exit.value, palmOK, ghost);

    state.prevNorm = norm ?? state.prevNorm;
    state.prevT = now;
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // Start camera on the iframe page
  document.getElementById('startIframe').addEventListener('click', ()=>{
    try{ app.contentWindow?.__hex?.startCamera?.(); }catch(e){}
  });
  </script>
</body>
</html>
