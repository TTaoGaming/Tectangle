#!/usr/bin/env node
// GoldCatalogAdapter v0 â€” builds docs/knowledge/GOLD_INDEX.md from docs/knowledge/*.md
import { promises as fs } from 'node:fs';
import path from 'node:path';

const ROOT = process.cwd();
const KNOWLEDGE_DIR = path.join(ROOT, 'docs', 'knowledge');
const OUT = path.join(KNOWLEDGE_DIR, 'GOLD_INDEX.md');
const SCRIBE_DIR = path.join(KNOWLEDGE_DIR, 'scribe_notes');
const INVENTORY = path.join(ROOT, 'docs', 'doc_inventory.json');

async function readJSON(file) {
  try { return JSON.parse(await fs.readFile(file, 'utf8')); }
  catch { return null; }
}

function parseFrontMatter(md) {
  // naive front-matter: look for lines starting with title/created_at
  const lines = md.split(/\r?\n/);
  const res = { title: null, created_at: null, tldr: null };
  for (let i = 0; i < Math.min(lines.length, 40); i++) {
    const l = lines[i].trim();
    if (l.startsWith('title:') || l.startsWith('title:')) {
      const m = l.match(/^title:\s*["']?(.+?)["']?\s*$/);
      if (m) res.title = m[1];
    }
    if (l.startsWith('created_at:')) {
      const m = l.match(/^created_at:\s*["']?(.+?)["']?\s*$/);
      if (m) res.created_at = m[1];
    }
  }
  // naive TL;DR extraction: first line starting with TL;DR or TL:DR or 'TL;DR:'
  const tldrLine = lines.find((l) => /^\s*TL;?DR\s*:/.test(l));
  if (tldrLine) res.tldr = tldrLine.replace(/^\s*TL;?DR\s*:\s*/i, '').trim();
  return res;
}

async function gatherFiles() {
  const files = await fs.readdir(KNOWLEDGE_DIR);
  return files
    .filter((f) => f.toLowerCase().endsWith('.md'))
    .filter((f) => !/^gold_(index|summary)\.md$/i.test(f))
    .map((f) => path.join(KNOWLEDGE_DIR, f));
}

function scoreByInventory(filePath, inv) {
  if (!inv) return 0;
  // attempt to locate by relative path
  const rel = path.relative(ROOT, filePath).replace(/\\/g, '/');
  const item = (inv.files || []).find((x) => x.path === rel);
  if (!item) return 0;
  let score = 0;
  if (item.classification === 'Gold') score += 10;
  if (typeof item.word_count === 'number') score += Math.min(5, Math.floor(item.word_count / 500));
  return score;
}

async function main() {
  await fs.mkdir(KNOWLEDGE_DIR, { recursive: true });
  const inventory = await readJSON(INVENTORY);
  const files = await gatherFiles();
  const entries = [];
  for (const file of files) {
    const md = await fs.readFile(file, 'utf8');
    const meta = parseFrontMatter(md);
    const score = scoreByInventory(file, inventory);
    // scribe note: docs/knowledge/scribe_notes/<basename>.md (first line)
    const base = path.basename(file).replace(/\.md$/i,'');
    let note = '';
    try {
      const sFile = path.join(SCRIBE_DIR, `${base}.md`);
      const s = await fs.readFile(sFile, 'utf8');
      note = (s.split(/\r?\n/)[0] || '').trim();
    } catch {}
    entries.push({ file, meta, score, note });
  }
  // sort by score desc, then created_at desc, then filename
  entries.sort((a, b) => {
    if (b.score !== a.score) return b.score - a.score;
    const ad = Date.parse(a.meta.created_at || 0) || 0;
    const bd = Date.parse(b.meta.created_at || 0) || 0;
    if (bd !== ad) return bd - ad;
    return a.file.localeCompare(b.file);
  });

  const lines = [];
  lines.push('# GOLD INDEX');
  lines.push('');
  lines.push('Auto-generated by scripts/gold_index.mjs. Do not edit by hand.');
  lines.push('');
  lines.push('| Rank | Title | Created | File | TL;DR | Scribe Notes |');
  lines.push('|---:|---|---|---|---|---|');
  entries.forEach((e, i) => {
    const rel = path.relative(KNOWLEDGE_DIR, e.file).replace(/\\/g, '/');
    const title = e.meta.title || path.basename(e.file);
    const created = e.meta.created_at || '';
    const tldr = (e.meta.tldr || '').replace(/\|/g, '\\|');
    const note = (e.note || '').replace(/\|/g, '\\|');
    lines.push(`| ${i + 1} | ${title} | ${created} | [${rel}](${rel}) | ${tldr} | ${note} |`);
  });
  lines.push('');
  lines.push('Notes');
  lines.push('- Source: docs/knowledge/*.md');
  lines.push('- Scoring: inventory classification when present, else fallback order');

  await fs.writeFile(OUT, lines.join('\n'), 'utf8');
  console.log(`Wrote ${OUT} with ${entries.length} entries.`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
